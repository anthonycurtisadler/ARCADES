ARCADES
Anthony Curtis Adler 
Copyright 2019
1. INTRODUCING ARCADES
	ARCADES is a text-based notetaking program designed around the needs of academic users. By relying on a command-based interface, ARCADES returns to the elegance and simplicity of index cards and the straightforward functional of pre-GUI computing, prioritizing speed of entry, powerful searching capabilities, and flexibility over a shallow learning curve and fancy formatting. It is not designed as a “virtual broom closet” in which sundry data can be tossed and recovered willy-nilly, but as a prosthetic extension of human memory – a tool for executing large-scale individual research projects in the humanities and for organizing reading notes and reflections. 	
1.1. GUIDING PHILOSOPHY
 ARCADES is designed around the following principles.
 1) It is better to have to learn something once than never be able to learn it all. 
	Most consumer software is designed to have as shallow a learning curve as possible. This is achieved not by having simple and intuitive commands, but by superimposing a graphical, mouse-based interface over the program’s inner workings. As a result, it is not only possible to use a program for years without having a clear idea of how to do things, but it is indeed rather difficult to ever get beyond the point where one is not  constantly figuring things out anew as if for the first time. Moreover, graphical user interfaces inevitably restrict the versatility of the program by foregoing the power of text-based commands for fixed rubrics. Nowhere is this flaw more evident than in search functions, which almost always offer a small sliver of the functionality of which data storage systems are theoretically capable.
2) It is better to have too many organizational paradigms than too few.
	When you start taking notes for a project, you don’t know where your research will take you. You can’t anticipate the direction that your notes will follow, or the kinds of connections that you will make between them. With this in mind, ARCADES encompasses multiple organizational paradigms. While it is possible to have a simple series of consecutively-numbered notes, one can also organize notes hierarchically or connect them with links. 
3) Medium data.
	Notes in a research project serve not as a mass of raw unprocessed data, but as a prosthesis for the human memory. A good notetaking system should facilitate the act of reading and interpretation by accompanying notes with rich classificatory information. To this end, ARCADES not only allows for keywords and tags, but also supports sequential keywords for representing pages, dates, indexes, and titles. Sequence keywords can be defined arbitrarily: it would, for example, be possible to keep track of three different separate page numbers. It even incorporates a primitive “knowledge base.” It can be taught that, say, “painters” and “sculptors” are both “visual artists”, allowing for one to search for visual artists and bring up every note with a keyword tagged painter or sculpture. And it can also be untaught this. 
4) Perspicacious organization. 
	GUI-based notetaking programs hide the data structure beneath a visual interface. As a result, individual notes can only be identified by their location on the screen or discovered through a search. ARCADES identifies each note through a unique index, making it possible to move a group of notes from one position to another, or even subordinate them to a top-level note, through a simple text command rather than tedious hunting and clicking. Links can be adding simply by entering an index as a key. When the location of the note is changed, associated links are automatically updated.
5) Organization is not presentation.
	Imagine that you have a stack of index cards. Each new note has a unique number written on it. These numbers constitute the inherent system of organization. Because this objective organization exists, however, it is possible to present the index cards however you wish. You can, of course, go through them in order. But you can also inspect them in reverse order, or lay out smaller groups of notes, or move from link to link, or even flip through them randomly. And you can “mark” notes as you pass through them, and then flip through the marked notes. This is the ideal after which ARCADES strives.
	While a digital notetaking system will never rival the palpable flexibility of physical notecards, most commercial notetaking software doesn’t even try, but instead fails to recognize the vital distinction between organization and presentation.  		
6) Notes should not be held captive.
	Every note in ARCADES, and every collection of notes, can be converted into text (a notescript) written in a rudimentary markup language.  These text files can, in turn, be converted back into notes. Indeed, when notes are entered via the console, markup language can be included, making it possible to embed notes within notes, or directly enter a notescript comprising several notes. Moreover, this makes it possible to go through a text file, and “highlight” notes with a few keystrokes, and in turn automatically extract these notes from the file. 
7) Extendibility.
	ARCADES is, above all, a paradigm for thinking about the practice of notetaking. Since my abilities as a programmer are modest, I suspect that many aspects of the implementation of ARCADES are lacking. Nor does the Python programming language lend itself to speed, and some aspects of the program – though not those that are vital to its use – are somewhat slow. The reliance on the shelve as a database, rather than more sophisticated platforms, also imposes limitations, such as on concurrent access to a single notebase.
	Nevertheless, I believe that it would not only be possible to overcome many of these limitations, but also to extend the features of ARCADES. The markup language is currently very restricted, but there is no reason why it cannot be replaced with something more sophisticated, including support for rich-text formatting, equations. It could also be assimilated to a subset of XML. It would also be possible to supplement the console-based system with limited GUI-functions, such as a dedicated visual text editor or more sophisticated means of displaying notes.
	Ideally, all such extensions should preserve the existing version as a proper subset. But, if this should prove impossible, then one should at least be able to easily convert the older markup language to the newer.
1.3 GETTING STARTED 
1.3.1 System requirements
ARCADES is designed and tested for use in Microsoft Windows 10. It is portable to other operating systems, but some modifications may be necessary. It may also not be possible to access the same notebase with different operating systems, since there are some differences in the implementation of the Python shelve.
1.3.2. Installing ARCADES
To run ARCADES, you will need to install Python 3.7. In addition you will need to install pyspellchecker, by Peter Norvig, and PIL (Python Imaging Library).
For further instructions, see:
https://pypi.org/project/pyspellchecker/ 
https://pillow.readthedocs.io/en/stable/#
The folder containing the program files should also include two empty folders, titled “textfiles”, “notebooks”, “pictures”,  “programs”, “diagnostics”, “registry.”
The files are available on github: https://github.com/anthonycurtisadler/ARCADES/tree/master
1.3.3. Running ARCADES
Navigate to the folder containing the program files, and double click on ARCADES.py. 
The startup menu gives you several options:
	(1) To see the help menus in large mode
	(2) To see the help menus in the compact mode
	(3) To start in the betamode
	(4) To start in the regular mode 
	(5) To start in advanced mode
	(6) To view file registry
The betamode disables exception handling, and is useful for debugging. The names of notebooks opened in the BETAMODE begin with “beta’.
Opening in the advanced mode will result in being asked if you wish to reconstitute the word dictionary (which is used for searching functions), the transposition table (which is used for links between notes), and the purge keys. The BETAMODE automatically makes these queries. 
 
PLATE 1.1: The startup screen 











	

PLATE 1.2: All the files

If you select (3), (4), or (5), you will then be asked if you wish to “Open a different notebook or QUIT.” If you press RETURN, you will automatically open the “defaultnotebook” or the “betadefaultnotebook.” (6) Calls up the file registry, which keeps track of which notebooks have been opened or closed.
If you enter “yes,” or another acceptable affirmative reply ('yes', 'Yes', 'yeah', 'sure', 'whatever', 'ja', 'jawohl,’  and SPACE+RETURN), then ARCADES will bring up the file menu. You can use this to select a file to be opened.
 
PLATE 1.3: The opening file menu


2. USING ARCADES
2.1 A BASIC OVERVIEW 
2.1.1. File structure
Every notebook consists in 4 different files: 3 files for the shelve, and a pickle file containing defaults and persistent attributes. The shelve filename has the suffix ND. So, for example, the “defaultnotebook” consists in four files.
1) defaultnotebookND
2) defaultnotebookND.bak
3) defaultnotebookND.dir
4) defaultnotebook.pkl
The pickle file can be reconstructed if it becomes corrupted. To do this, simply delete the appropriate pickle file and then reopen the notebook. You will have to start it as a new notebook, though. Hence, if you erase the pickle dictionary while keeping the shelve file, you will need to explicitly enter 'defaultnotebook' as a new notebook.
2.1.2. Data structure
2.1.2.1. The notebook
A notebook consists simply in a series of uniquely indexed notes. 
2.1.2.2. Indexes
Indexes consist in an integer followed by a sequence of natural numbers.
For example: 1, 2, 1.1, 1.2, 2000, 2000.200.12, -1, -50.1.60, 0, 0.1.2.
Negative indexes are reserved for “soft-deleted” notes, while the indexes greater than equal to 0 and less than 1 are reserved for use as a temporary location.
2.1.2.3. The note
A note consists of a list of simple keywords, keywords of one or more tags, keywords with tags and knowledge definitions, sequence keywords of various types, as well as the text of the note. Notes do not have titles separate from the text, though sequence keywords could be used to record titles.
2.1.2.4. Keywords
Keywords can include any Unicode characters, including numbers and spaces, excepting the following reserved characters: PERIOD(.),  COMMA (,), SEMICOLON(;) , POUND(#), CARET(^), SQUARE BRACKETS ([ ]), PARANTHESES ( ( ) ), QUESTION MARKS (?), DOLLAR SIGN ($), SLASH (/), UNDERLINE (_), and AT (@), which is used for sequence keywords. 
While most of these are not strictly forbidden, they may interfere with search capacities and other functions, and should be avoided. SPACES in between words are acceptable.
2.1.2.5. Tags
Tags should follow the same rules as for keywords, though PERIODS are also forbidden.
2.1.2.6. Text
The note text consists in a string of Unicode characters, using Unicode encoding UTF-8.
Reserved characters include RIGHCARET (‘>’), LEFTCARET (‘<’), CURLY BRACKETS (‘{‘,’}’), and UNDERLINE (‘_’). Reserved codes include:
/BREAK/  /NEW/ [integer #]  /DEF/  /COL/ /ENDCOL/  /SPLIT/  /M/  /ENDSPLIT/  /C/  /R/
The special codes are used to format the note for display. 
2.1.2.7. Metadata
Metadata includes a list of dates, the size of the note, and the username. 
2.1.3. Basic workflow
In ARCADES, all actions are initiated through the command line. It is possible to enter one command or multiple commands at once.  While there are dozens of different commands available, it is also possible to operate ARCADES with only three commands: enter,  PLUS (+), and quit. The command enter displays the next note in the notebook, PLUS enters a new note, and quit
quits the notebase.
 
PLATE 2.1: Press enter to display the next note. 
The basic workflow, in other words, consists in entering new notes and flipping through old notes. By simply pressing return over and over again, you can cycle through all the notes in the notebook.  
2.2. COMMANDS
2.2.1. The command prompt 
The command prompt displays essential information about the status of the notebook, including the name of the current notebook and project, the current index, the automatic prefix added to entered indexes, a <#> if the current note has been marked, and [++] or [+++] to indicate if the continuous entry mode is on.   
The format of the command prompt is as follows, with optional information underlined and in italics:

NOTEBOOK/PROJECT: CURRENTINDEX #MARKED INDEXPREFIX  CONMODE

 
PLATE 2.2: The command prompt
2.2.2. Basic command syntax
A basic command consists one or more command phrases. 
2.2.2.1 Multiple commands
If there are multiple command phrases, each command phrase is separated by a double SLASH.
(1) defaultnotebook:4017.1.12 4017 +//delete:5//quit
| Adds a new note, deletes note at index 5, and quits the notebook.
2.2.2.2. Automatic repetition
To repeat a command N times, add **N at the end of the command, preceded by a space.
 2.2.3 The command phrase
2.2.3.1. Command and predicate
 The command phrase consists in a command and, optionally, predicate, in which case the command and the predicate are separated by a COLON. 
2.2.3.2. Elements of the predicate
 The predicate consists in the following elements: values, limits, and modifiers.  
These are combined as follows:
COMMAND:VALUE1;VALUE2;VALUE3   MODIFIERS LIMITS
The values are listed immediately after the COLON following the command. If there is more than one value, the values are separated by SEMICOLONS.  A SPACE is placed at the end of the sequence of values. All the other elements are placed after the values, and are separated by SPACES.
2.2.2.1. Commands 
Commands include simple commands which do not take a predicate, and regular commands, which to take a predicate.
2.2.2.1.1. Simple commands
Valid simple commands include: 
COMMA, PERIOD, ", ',  <,  =,  >,  [, ], /, actdet, activedet boxconfigs, carryall, carryoverkeys, changecodes, changecommandmacros, changekeydefinitions, changekeymacros, changeknowledge, changemacros, clearcodes, clearcommandmacros, cleardefinitions, clearkeydefinitions, clearkeymacros, clearkeys, clearknowledge, clearlog, clearmacros, clearmarks, clearpurgekeys, clearsearchlogconent, conchild, connext, constitutedates, currentproject, curtail, deeper, defaultcodes, defaultcommandmacros, defaultkeydefinitions, defaultkeymacros, defaultkeys, defaultknowledge, defaultmacros, deletedefaultkeys, deletekey eliminateblanks, endlinking, endlooping, enterback, enterchild, fields, first, flipout, flipproject, help, hyperone, hyperthree, hypertwo, inc, ind, indentmultiplier, indexes, iteratemodekeysfortags, keystags, killclusters, last, leftmargin, loadconfigurations, marked, negativeresults, negresults, orderkeys, compress, quickenter, recordcodes, recordcommandmacros, recordkeydefinitions, recordkeymacros, recordknowledge, recordmacros, refresh, resetl, resetlimitlistsaveconfigurations, searchlog, setreturnquit, shallower, showdel, showdet, showflip, showflipbook, showlimitlist, showprojects, showpurgekeys, showsequences, showsettings, showtags, showuser, smallsize, spelldictionary, startlinking, startlooping, streams, tag, tags, updatetags, 
2.2.2.1.2. Binary commands
Binary commands used to toggle a setting on and off. They include:
allchildren, allknowledge, autobackup, childrentoo, enterhelp, formathelp, enternext, fulltop, randomoff, randomon, keyafter, keysbefore, rectify, returnquit, shortshow, spelling.
2.2.2.1.3. Ordinary commands
Valid ordinary commands are: 
+, ++, +++,  -, SEMICOLON, SEMICOLON + SEMICOLON, ?, ??, ???,  addfield, addkey, addkeys, addmarks, ahowdatedictpurge, all, chain, changedet, changekeys, changeuser, clear, cleardatedict, cluster, conflate, constdates, copy, copyfrom, copyto, correctkeys, cpara, defaultspelling, delete, deletefield, deletemarks, deletestream, depth, descendents, editnote, editnotekeys, editnotetext, eliminatekeys, enter, flipbook, footer, formout, grabkeys, header, histiogram, hop, key, keys, learn, limitlist, link, loadbyparagraph, loadproject, loadtext, loop, mergemany, mm, move, multi, newkeys, newproject, permdel, quit, redo, reform, resize, resumeproject, rev, revise, s, saveproject, search, setlongmax, setpurgekeys, show, showdatedict, showmeta, showspelling, showstream, sidenote, size, skip, split, splitload, switch,  terms, textsearch, undel, undo, unlink
2.2.2.2.  Values
Values can consist in 1) an integer 2) a string 3) a single index 4) multiple indexes. If values are essential to the execution of a command, ARCADES will query the user for values that have been omitted from the command phrase.  A value, if not the last in the series, can be left empty. 
2.2.2.2.1. Multiple indexes
Multiple indexes may be listed either through a range indicated by a DASH (e.g. 1.1-1.9.8;-1-50,-10--5), a succession of single values separated by commas, (e.g. 1,2,3.1,5,8), or a combination of an arbitrary number of ranges and single values separated by commas. (e.g., 1,4-6,9-10,11.1-14,19).  Values need not be entered in ascending order, though in most instances the order of entry is of no consequence.
2.2.2.3 Modifiers 
Modifiers are used to indicate binary parameters. 
The modifiers include: /$, /&, /*, /?, /=
The use of these modifier depends on the command. 
2.2.2.4. Limits
Some commands, including the search command, can be limited to a certain range of indexes, a set of fields, or to a range of dates. 
Limits should be placed at the end of the command phrase, with the entire limit phrase preceded by   two PERCENTAGES (%%), and each limit term separated by a comma.  Acceptable limit terms include the following:
FLIPBOOK or !!  -- Limit to the flipbook
INDEX-INDEX – For a range of indexes
YEAR(-MONTH)(-DAY)/(YEAR)(-MONTH)(-DAY)– For a range of dates. 
FIELDNAME – For a field
If a PLUS (+) is placed before the limit term, the new will be the logical union with the old limit – otherwise, the logical intersections.
Some examples:
(1) ?:<frog>  %%1-1000       | Searches for the keyword “frog” in indexes 1 to 1000.
(2) ?:elephant %%2019-01-01/2019-01-31 |
Search for “elephant” in the main text of notes written in January, 2019.
(3) ?:toad %%1-10,+20-30,+40-50 | Search for “toad” in the main text of notes 1-10,20-30,40-50.
(4) ?:giraffe %%FROG  |Search for “giraffe” within notes in the field “FROG”
(5) ?:sloth %%FLIPBOOK   |Search for “sloth” in the flipbook.
2.2.3. Refeeding results
Any command which yields a list of indexes or ranges of indexes, or a list of searchable terms, can be refed into another command by as follows:
1) COMMAND1 =>COMMAND2:?    | To refeed indexes, or index-ranges.
2) COMMAND1 =>COMMAND2:??   | To refeed keys or words from the text.
Refeeding can be done more than once, though, for practical purposes, twice is the limit.
3) COMMAND1 =>COMMAND2:?? =>COMMAND3:?
The question mark or double question mark can appear in any of the values after the command, and in either order, though, again, the possibilities are rather limited.

 
PLATE 2.3: A search refed into the show command. 
 
PLATE 2.4: The keys from index 3 fed into a search command. Notice that search has to used for the search command instead of a single question mark.

 
PLATE 2.5: The keys from index 3 fed into the search and then displayed.
2.2.4. Fetching results
ARCADES makes it possible to automatically retrieve marked indexes, the last entered note, and search results. 
2.2.4.1. Simple fetches
The following fixed expressions can be used to retrieve various classes of data.
[?] : Marked indexes
[*]: The flipbook
[/]: The last entered note
2.2.4.2. Fetching search results
ARCADES also allows you retrieve the results from previous searches. The most recent search is numbered 1, the second most recent 2, and so on.  
{{N}}: The N’th previous Search result
 
PLATE 2.6: Displaying the last search result
2.2.4.2.1. Showing previous search results
The searchlog command is used to show all previous search results.
2.2.4.2.1.1. Combining previous searches with the search log
The search log allows you to combine the results of previous searches. For a discussion of this feature see INDEX below.
2.2.4.2.2. Clearing the search log
The clearsearchlog command empties out the search log when it has become too large.
2.2.4.3. Grabbing files
It is possible to insert the content from a text file in the “textfile” folder by enclosing the filename, without the .txt suffice, in double curly brackets, preceded by an AT.
*2.2.4.4. List comprehensions
A list comprehension can be inserted into a command by enclosing a valid Python expression, without brackets yet preceded by a POUND (#), in double curly brackets.
This leverages the power of the python eval function, and hence it must be used with care.

 
PLATE 2.7: Search results
 
PLATE 2.8: Inserting a text file into a note.

2.2.4.4.1. Simple list comprehensions
Simple list comprehensions involve expressions that do not refer to objects defined within the ARCADES program.
This could, for example, be used in order to show every third or fifth or seventh index.
 
PLATE 2.9: A simple list comprehension, showing indexes that are multiples of 3.
2.2.4.4.2. Complex list comprehensions
Complex list comprehensions make use of objects defined within the Norescription program. This is a powerful, yet tricky, feature, since it demands an acquaintance with the interior architecture of ARCADES. For a list of useful objects, see APPENDIX A. 
 
PLATE 2.10: A complex list comprehension showing all notes with ‘7’ in their index.
 
PLATE 2.11: Another example of a complex list comprehension.

 2.2.5. Variables
Variables can be used to store the results of searches, lists of keys, and even text, and then feed these back into commands as values.
2.2.5.1. Defining variables
To define a variable, simple refeed the results of a command into a variable name. Variable names must be written in capital letters and not have any non-alphabetic characters.
For example:
	(1) keys:1-10 =>KEYS | Feeds the keywords for notes 1-10 into the variable KEYS
	(2) show:1 =>TEXT | Feed the text for note 1 into the variable TEXT
	(3) ?:<Husserl> =>INDEXES | Search for the keyword Husserl and feed into INDEXES
2.5.5.2 Using variables
To retrieve the contents of a variable, simply include it in double curly brackets.
For example:
	(1) ?:{{KEYS}} | Searches for KEYS
	(2) +:Husserl;{{TEXT}} || Enters a new note with TEXT as the note text.
	(3) show:{{INDEXES}} || Show the notes in INDEXES

 
PLATE 2.11b Variable assignment 
2.3 THE NOTE
2.3.1 Elements of the note
Every note consists of an index identifying it; a set of zero of more keywords; and the text of the note. A notebook consists in a set of notes with unique indexes.
2.3.1.1. Indexes
Indexes consist in an integer followed by a sequence of natural numbers.
For example: 1, 2, 1.1, 1.2, 2000, 2000.200.12, -1, -50.1.60, 0, 0.1.2.
Negative indexes are reserved for “soft-deleted notes,” and range 0-.9_ is used as a temporary holder for the descendants of notes that are being moved from one location to another.
Notes are stored in a dictionary-like shelve, with the string representation of the Index (an object of type Index) serving as the key. Hence, every index in a given notebook must be unique; no two notes within the same notebook can have the same index. If you try to compose a note, or move a note, on to an index that is already taken, then it will be assigned instead to the next available index position. 
2.3.1.1.1. Head, tail, size, rank, differentiator, identifier
An index, as mentioned, can consist in an integer followed by an arbitrary number of natural numbers, with all of the numbers separated by a single period. Let us refer to the integer value as the head, and subsequent values as tails: tail rank 1,tail rank 2,tail rank 3,tail rank 4. The rank of the tail is its position after the head, which is rank 0. The head and the tails comprise the elements of the index, and thus one could also say that the head is the element rank 0, and tails all the elements of a rank > 0. The size of an index is the rank of the highest ranking tail, or 0 if the index is tailless. For any two indexes p and q, the differentiator rank is the lowest rank of the tails in p and q that are not equal in value. If the head of p and q are different, then the differentiator rank is 0. We then say that they have neither a differentiator nor an identifier. If two notes p and q have a differentiator of rank R, then then differentiator value of p and q, respectively, is the value of the elements of p and q rank R. 
If the differentiator rank of two notes is > 0, then they also have an identifier, which is the segments of a rank less than the differentiator. The identifier rank is equal to the size of the identifier. 
So, for example, suppose that index p is 1.5.7.13. The head of p is 1, tail rank 1 is 5, tail rank 2 is 7, and tail rank 3 is 13. Or conversely the tail rank of 5 is 1, or 7 is 2, and of 13 is 3. And thus the size of this index is 3. And if index q is 1.5.8.14, then the differentiator of p and q is of rank 2, while the identifier is 1.5, which is of rank 1. The differentiator values of p and q, on the other hand, are, respectively, 7 and 8.
If there exist no tail in p of equal rank with a tail in q that does not have an equal value, then we say that p and q have an identifier but no differentiator. This does not mean, however, that the notes are identical, since they may not be the same size. In this case, though, the identifier---the common segment---will be equal to the smaller of the two notes.
2.3.1.1.1.1. Ordering relations between indexes
A strict ordering holds between indexes: for any two indexes p and q, p=q iff the head and all the tails are identical, where p<q iff either:

1) The differentiator value of p is less than the differentiator value of q 
2) There is no differentiator, but the size of p is small than the size of q.
	3) There is neither differentiator nor identifier, and the head of p is less than the head of q.
For example:
-2<-1 (By rule 3)
-1<-1.1 (By rule 2)
0<0.1 (By rule 2)
1<2 (By rule 3)
1.1 < 1.2 (By rule 1)
1.1 < 1.1.1 (By rule 2)
2.3.1.1.1.2. Familial relations between indexes.
In addition to the ordering relation, one may also attribute familiar relations to indexes.
There are two kinds of familiar relationship: sibling and parental.
A sibling relationship exists between indexes p and q iff they have a differentiator. If p and q have a differentiator, and p < q, then p is older than q. 
A parental relationship exists between p and q iff they have an identifier but no differentiator. If p and q have an identifier but no differentiator, and p < q, then p is the parent of q. A parental relationship has always has a degree, which is equal to the difference between the size of q and the size of p. If for p and q, q is the child of p and there exists no r such that r is the child of p, and r < q, then q is the first child of p. 
For example:
-3 is the older sibling -2. 
1 is the older sibling of 2.
2.1 is the older sibling of 2.2 
2 is the parent degree 1 of 2.1
2.1 is the parent degree 2 of 2.1.1.1
2.2 is the parent degree 3 of 2.2.13.13.13 
2.3.1.1.1.3 Friend, sonbae, hubae, mates, soulsisters.
Indexes without a familiar relationship are friends. If p and q are friends, and p < q, then p is the sonbae (선배) of q and q is the hubae (후배) of p. The best friend of p is the sonbae or hubae within the notebook with the closest value. For example: if the notebook consists in indexes 1, 1.1, 2, 2.1,2.1.1, and 3, then 1 and 2.1 are friends, and, moreover, 1 is the sonbae of 2.1. The mate of an index p is the first possible hubae in the index. 1.1,1.2,1.2.1,1.3.1 all have the same mate: 2. 
Two indexes are said to be soul-sisters if they have a differentiator, and there exists no possible r, such that r has the same differentiator as p and q, and p<r<q. For a given set S of indexes with a common differentiator, then if p,q ∈ S and p < q and there exists no r ∈ S such that p <r < q, then we say that p and q are closest siblings in S. If S is the set of all the indexes in a given notebook N, then we say that p and q are closest siblings in N. 
2.3.1.1.1.4 Descendents
One index p is said to descend from another index q iff p < q, and there exists some rank x > 0 such that every element of p with a rank < x has the same value as the element of q with the same rank. We can then say that q starts with p.
Consider, for example, indexes p and q where p = 1 and q = 1.13.19.12. Since q starts with p, p is clearly a descendent of q. 
The descendants of p in N consists in the set of  indexes q such that q ∈ N and q is a descendant of p. 
A tribe consists in the union of p and all its descendants. 
An index p is said to be a direct descendent of q iff q is a descendent of p, and all the elements in q of rank greater than the size of p are equal to 1. Observe that an index can have descendants without having any direct descendants. 
For example: 3.9.17.1.1.1.1 is a direct descendent of 3.9.17
An index p is said to a be a closest descendent of q  in N iff q is a descendent of p, and there exists no r ∈ N such that r is a descendant of p, r is the same size as q, and r < q. 
A nuclear family consists in the union of p and all its direct descendents.
A modern family consists in the union of p and all its closest descendents.
A modern family can be a nuclear family, but does not have to be!
*2.3.1.1.1.4.1. Desiderata
While at present ARCADES only formally recognizes some of these relationships, it would be wonderful if it could recognize all of them.


2.3.1.1.1.4.2. The abbreviated index form
Very long indexes, with multiple repeated values, appear, and can be entered, in an abbreviated form. Please observe, however, that the long form of the index is always used internally.
1.1.1.1.1.1  ≈ 1^6
1.1.1.2.1.1 ≈ 1^3.2.1^2
7.7.7.7.7.7.7.6.6.6.6.6.6.5.5.5.5.5.5.4.4.4.4.3.3.3.3.2.2. ≈ 7^7.6^6.5^5.4^4.3^3.2^2.1
2.3.1.1.2 Assignment of indexes
ARCADES does not require that notes be assigned to sequential indexes. It is perfectly acceptable to have a notebook consisting of the indexes 1, 13, 1999, or, say, only of indexes with prime numbers. And it is also perfectly acceptable to have orphans – notes without a parent. 
Nevertheless, unless you opt to assign the index manually when entering new notes, ARCADES will automatically assign the index value. The basic entry function (+) will assign the new note either to the closest sibling of a “top-level” note, or to the closest mate of a note with size > 0. For example: 1 => 2; 2.1 => 3. The “next” entry function (++) will assign the new note to the soulsister, or closest available sibling, of the last note. For example: 1 => 2, 2.1 = 2.2, 3.3.1 => 3.3.2. The “child” entry function (+++) will assign the new note to the first child, or the closest child. 1 => 1.1, 2.1 = 2.1.1. 
*2.3.1.1.3 Modifying the Index object
All the properties of the index are defined through the Index class, contained in the indexclass module. This makes it fairly easy to change the properties of the Index object, allowing more radically different organizational principles than are now possible. 
2.3.1.1.1.Fields
Fields, which are an entirely optional feature of ARCADES, and can be used to divide the notebook into different sections. 
A field is assigned to a set of indexes. It is possible to assign a field either to 1) a range of consecutive top-level  (size=0) indexes regardless whether they are present in the notebook or 2) a range of indexes, greater than p and less than q and of arbitrary size, that are actually present in the notebook, or 3) to any set of indexes, whether or not they are present in the notebook. 
A given note at a given index can belong to one field at most.
Consider the following examples:
Suppose that the notebook contains notes at indexes 1,8,19,27.
(1) addfield:SLOTH;1-100   |  Will add the field SLOTH to all indexes that are present in the notebook within range 1-100.
(2) addfield:SLOTH; 1,2,3,4,5,33.1 | Will add the field SLOTH to all indexes 1-5 and 33.1, regardless of whether they are present in the notebook.
Fields can be overwritten, and deleted, with these same principles applying.
Field names need not be in all-caps; they can indeed include spaces and non-reserved special characters.
2.3.1.2. Keywords
Whereas indexes uniquely identity the relative position of a note within the notebook, and fields can be used to structure the notebook as a whole by dividing it up into regions, the keyword is the basic means for categorizing individual notes during and after composition, identifying their content and establishing expressive relations to other notes.  While it is possible to search for both keywords and words within the text, keyword searches are by far the most powerful means of retrieving useful information from the notebook. 
2.3.1.2.1. Ordinary Keywords 
The ordinary keyword – or, rather, keyphrase – consists in a string of characters, including spaces and non-reserved symbols. The keyphrase may indeed include all Unicode characters, though the standard terminal may forbid their entry. 
Keywords, like fieldnames, are case sensitive. However, in sorting and displaying keys, and collecting the keys from over a group of notes, ARCADES distinguishes between all-cap keywords, capitalized keywords, and lower-case keywords, and, in certain instances, allows you to exclude one or the other of these types. Hence it is strongly recommended that, in assigning keywords, you obey certain classificatory conventions, such as using ALLCAPS for very general categories of information, upper case for proper names, and lower cases for general concepts.
 
PLATE 2.12: Keywords for a note recording Kant’s definition of analytic and synthetic judgments in the Prolegomena. 
2.3.1.2.2. Tags 
Keywords can be followed with one or more tags, serving as a further level of classification. The tags should follow a slash (/); multiple tags are separated by a period.
So for example: 
	Sloth/animal      
	Penguin/bird.Arctic.flightless.monochrome 
	Emu/bird.Australian.flightless.		         
Searching for the tag “flightless” would retrieve notes with the tags “Penguin” and “Emu.”
A given tag need only be associated once with a give keyword. Or, put another way, if you search for a tag it will retrieve all the notes classified with the keywords associated with it, and not just those notes in which the association has been made explicit.  
2.3.1.2.2.1. keysfortags
The command keysfortags shows tags together with their keys.
 
Plate 2.12b: Keys for Tags

2.3.1.2.3. Knowledge
ARCADES includes a simple knowledgebase, allowing for tags to be classified under higher-order concepts. A single tag can be classified under an arbitrary number of different concepts, and an arbitrary number of levels of classification are permitted, allowing for complex ontological trees to be superimposed atop the notes. While knowledge may be imputed, along with keywords and tags, when entering a note, it is also possible to manipulate knowledgebase directly through the <learn>, <forget> and <changeknowledge> commands. 
Concepts to be learned are introduced with an EQUAL (=) following either a tag, or a subordinate concept.
For example:
Lupu/frog=amphibian=vertebrate=animal=living being=being
ARCADES does not forbid circular assignments, such as, for example:
Lupu/animal=creature, Girin/creature=animal.
It will automatically stop rather than crash.

 
PLATE 2.13: Knowledge base 
2.3.1.2.4. Links
If the index of a note in the notebook is entered as a keyword, it automatically becomes a link, establishing a connection between the note in which it was entered as a keyword and the note to which it refers. Links are unidirectional; they point one note to another note. ARCADES keeps track of these indexes, and automatically changes them when the note to which they refer has been changed. 
2.3.1.2.4.1. Linking tools
In addition to entering links manually, either when first composing the note or with subsequent editing, ARCADES also offers several tools for quickly linking notes together. These include some functions which apply to existing notes, and others which can be used when entering a series of notes for the first time.
2.3.1.2.4.1.1 Tools for linking existing notes
The command link takes a group of notes and links each note to all the other notes. 
If, for example, you were to link notes at indexes 1,2,3,4,5,6,8,9,10, then each of these notes would have 9 links, and hence 9 keywords, added to it. 
Because the number of additional keywords added to each note increases in direct proportion to the number of notes being linked, this function is limited to 10 notes. If you try to link more than this, it will yield an error.
The command chain can be used to enchain a series of notes, linking each note to the next. 
For example:
chain:1,2,3,5,6  |links 1 to 2, 2 to 3, 3 to 4, 4 to 5, 5 to 6.
chain:1,6,2,5,3,4  |links 1 to 6, 6 to 2, 2 to 5, 5 to 3, 3 to 4
chain:1-10 |links 1 to 2, 2 to 3, …
The loop creates a chain, and then links the last note in the chain to the first.
For example:
loop:1,2,3,5,6    |links 1 to 2, …, 5 to 6, 6 to 1
To remove links, you can delete links manually, or use unlink, which removes all the links from the range that has been entered.





2.3.1.2.4.1.2 Tools for linking during entry
The command startlinking links all the notes that are subsequently entered. The command startlooping, likewise, initiates a loop. To terminate, use endlooping or endlinking. 
2.3.1.2.2.4. Sequences 
ARCADES recognize sequences as a special class of keywords. A sequence combines a keyword with an instance of a sequential value – a member of a set of well-ordered values, such as strings, real numbers, dates, or even indexes. 
2.3.1.2.2.4.1 Basic syntax
A sequence-keyword consists in a keyword and a sequence-value, separated by AT (@) and with an optional type-designator placed before the sequence-value. 
The type-designator is used only if the sequence-value is a date or an index.  Strings and real numbers are recognized automatically. Integers are recognized as real numbers, and represented as “floating point values.” 
For example:
page@1, page@80, page@99.7
Strings are also automatically recognized. String sequences can be used to associate alphabetically-searchable labels—titles, names—with notes. While “Heidegger” or “Hegel” could be entered as simple keywords, you could also add them in as name@Heidegger, name@Hegel, or philosopher@Hegel, and then, in turn, search for notes with names starting with an “h”.
To enter a date, use the at-symbol and POUND-symbol (“@#”), followed by YEAR, MONTH, and DAY, separated with hyphens. 
For example:
date@#1970-01-07, date@#1770-03-20, date@#1970,date@#1950-01
To enter an index, use the at-symbol followed by an underline (“@_”), 
For example:
index@_1.1.1, index@_1.2.3, mynote@_13.13.13

 
PLATE 2.14: Enter a link keyword.



 
PLATE 2.15: Automatically entering a loop



2.3.1.2.2.4.2 Initiating a sequence
Sequences are initiated simply by entering a new sequence-keyword into the database either when composing a new note or editing the keywords of an existing notebook. As soon as a sequence is initiated, ARCADES starts recording all the sequence-values associated with that keyword.
Please note that, while any keyword can be associated with any sequence type, once a certain keyword has been associated with a certain sequence type then only this will be recognized. If, for example, you enter date@1970-01-01 with the POUND missing, then it will be recognized as a string, not as a date. If you follow the correct syntax on subsequent notes, they will not be included in the sequence. The sequence will still appear as a key-word, and yet it will be accessible through the sequence-search function.
2.3.1.2.2.4.3 Keeping track of sequences
To view all of the sequences in the notebook, use the showsequence command. The showsequence command also offers the option of “correcting” sequences by deleting them, making it possible to reinitiate the sequence. This should be used sparingly---only if a mistake has been made initiating a sequence. 
 
PLATE 2.16: Showing the sequences in the notebook


2.3.1.2.2.4.4 Searching for sequences
It is possible to search over keyword-sequences, finding all the notes with values associated with a given keyword falling within a certain range. The basic syntax for a sequence keyword, included within a search phrase, is as follows <SEQUENCE@VALUEFROM/SEQUENCE@VALUE2>. It is possible to omit the value before or after a slash. If a  LEFTBRACKET follows the LEFTARROW, or a RIGHTBRACKET proceeds the RIGHTARROW,  indicated, respectively, a search for sequences with values that are greater  than or less than the given value, rather than less than equal or greater than equal. If you are searching for an index or date sequence, you should use POUND or UNDERLINE after the ATSIGN. To find all values for a given sequence, you need enter <SEQUENCE@TYPEMARK>, where the TYPEMARK is one of the following:
^ | floating point sequence
$ | string sequence 
# | date sequence 
_ | index sequence 
+ | integer sequence 

 
PLATE 2.17: Searching for a sequence
2.3.1.2.2.5 Default Keywords 
If you are entering a series of notes on the same topic, you may set default keywords which will be automatically added to the note. The default keywords are displayed before the command prompt. To add default keys, use addkeys;  to add a single key, use addkey, to delete the most recently added key, use deletekey; to clear all defaultkeys, use clearkeys; and to revise the default keys, deleting a selection and then adding new keys, use deletedefaultkeys. The default keys are stored as a list, not a set: it is possible to have redundancies, though these will be eliminated when the keywords are added to a note, since the keywords of a note are stored as a set.
2.3.1.2.2.5.1. newkeys
The command newkeys can be used to load keywords stored as a “key macro” (See sect. 2.13.1.3) into the default keywords. It accepts one value, the name of the macro, and the modifier /$, which can be used to keep the existing default keywords.
2.3.1.2.2.5.2. grabkeys
The command grabkeys can be used to load keywords stored in a single note or a collection of notes.
It accepts one value, the collection of indexes of the notes to be loaded, and the modifiers /$, which excludes “all-cap” keywords, and the modifier /&, which excludes capitalized keywords.
2.3.1.2.2.5.3. Default Sequences 
Sequence keywords can be used as default keywords. If you enter a keyword sequence with a determinate value, such as “book@5”, then the specific value will be included in every new note. If, however, the determinate value is replaced with a question mark (?), then ARCADES will ask for the value when the note is entered. 
2.3.1.2.2.6. Settings for displaying keys.
The following binary commands can be used to determine how keys are presented when notes are displayed.
	(1)	showtags 	| Includes tags when displaying keys
	(2) 	orderkeys	| Arrange the keys by increasing frequency.
2.3.1.3. Text
The text of a note consists of a simple string of Unicode characters. While the text of a note can contain the EOL character, this is not necessary; the text of the note will be automatically formatted to reflect the size of the note, as indicated in the metadata, with the ultimate appearance of the note reflecting both the content of the string of the note and the size.
2.3.1.3.1. Basic formatting 
ARCADES presently supports Unicode---though it may not always be possible to enter special characters in the terminal---but it does not support advanced formatting, such as colors, highlighting, or bold text. Formatting is restricted to centering and right-justifying text. 
This formatting is indicated by the special codes “/C/” and “/R/.” For these to function properly, there must be a space after the second slash, and an EOL must appear at the end of the relevant text, which, when using the text editor, can be achieved by a vertical line (|). 
2.3.1.3.2. Note breaks and new notes
Even though the text of a note consists in a single string, it is possible to have it appear as a series of distinct notes. This is achieved through the special codes “/BREAK/” and “/NEW/”.
2.3.1.3.3. Columns 
ARCADES permits formatting into columns. A series of columns is initiated with “/COL/” and terminated with “/ENDCOL/”. Each line of text is divided up using an underline (_) to distinguish columns. Keep in mind that an EOL mark must be included at the end of each row. It is recommended, therefore, to enter columns in the poetry mode (see 2.3.2.1.2.1.2.), since this automatically adds an EOL after each entered line.














PLATE 2.18: Centering and right justification
 
PLATE 2.22: Inspecting the text of a note
   
PLATE 2.19: Sequences as default keys
 
PLATE 2.20: A note divided into three columns.
2.3.1.3.4. Splits
An alternative---and perhaps easier---way of entering columns is to initiate the columns with “/SPLIT/”, terminate with “/ENDSPLIT/”, and separate the text of the individual columns with “/M/”. 
Notice that the formatting is a bit different than with the columns. Splits is recommended for larger sections of text.
 
PLATE 2.21: “Splitting” into columns
2.3.1.3.5. Inspecting the text
It is possible to inspect the entered text of a note to see how it appears without formatting.  To do this, use the inspect command, followed by the index of the note to be inspected.



 
PLATE 2.23: Using /BREAK/ and /NEW/ to segment notes.
2.3.1.3.6. Modifying the presentation of the note text.
The following commands, each of which accepts a single integer greater than equal to zero as a value, can be used to modify the appearance of the note text. 
	(1)	header		| adds lines to the head of the note text
	(2) 	footer 		| adds lines to the tail of the note text
	(3) 	leftmargin	| adds spaces to the left margin of the note text
There is also a single binary command, rectify, which equalizes the width of the head (containing the keywords) and the body (containing the text) of the note.
 
PLATE 2.23.1. seqformtwo used to change for formating of sequences displayed in the text.
2.3.1.3.6.1. Including keywords in the text with seqintext. 
The binary command seqintext can be used to include sequence keywords in the note of the text, uncluttering the keywords while at the same time allowing for clearer presentation of especially pertinent information. It can even be used to include the equivalent of a title in each note, show at the the top of the text, simply by using title@TITLE as a keyword.
2.3.1.3.6.1.1. Order of keywords in the text.
The sequences keywords are included in the text in the following order
1) The main sequences, which can be user defined, but default to: title, author, date, datefrom, dateto, book, page, chapter, section.
2) Projects.
3) Other sequences
2.3.1.3.6.1.2. Adjusting formating of sequences in text, and changing the main sequences.
ARCADES provides two commands that can be used to adjust the formating of sequences when displayed within the text of the note: seqformone, which is used to adjust the character that appears after the first two sections, and seqformtwo, which determines the character that separates off the sequence keywords from the rest of the notetext.  Both of these accept one value, - the breaking characters -- and include a variety of options. If entered up a value, they will call up a self-explanatory menu.
The command mainsequences can be used to change the main sequences. It accepts a single value: a list of sequences separated by commas. It is possible to restore the defaults by entering ‘d’.
2.3.1.4. Metadata
Every note includes metadata. This includes the size of the note expressed as a single integer indicating the width of the note, the name of the user who entered the note, and a list containing the timestamp of the creation of the note as well as every subsequent revision.
 
PLATE 2.24: Showing the metadata of a note.

2.3.1.4.1. Metadata commands
ARCADES offers the following commands for changing and viewing metadata.
2.3.1.4.1.1. resize
The command resize (alternate forms: size, rs) can be used to change the default size of note. It accepts a singer integer value, which corresponds to the width in characters of the note.
2.3.1.4.1.2. changeuser
The command changeuser changes the active user as listed in the metadata of the note.
2.3.1.4.1.3. showmeta
The command showmeta shows the metadata for the note at the index given as its value.
2.3.1.4.1.4. showuser
The command showuser displays the default name of the user which is included in the metadata when the note was entered.
*2.3.1.4.2. Note on date structure and expandability
The metadata is stored in a dictionary, using the keys “size”, “user”, and “date”. Theoretically, it would be quite easy to add additional kinds of metadata while maintaining compatibility with existing notebooks.
2.3.2. ENTERING A NOTE  
ARCADES allows rapid entry of new notes with a minimum number of keystrokes. It is possible, indeed, to initiate and terminate note entry only using the RETURN key.  This comes at the cost of some degree of flexibility; rather than offering a full-fledged text editor, ARCADES uses a simplified note inputter, which forbids returning to previous lines and correcting them, or moving the cursor around beyond what is possible through the standard buffered text input function.
*These limitations, together with some of the restrictions on formatting – and perhaps also some multi-platform compatibility issues – could be eliminated by making use of the curses module. 
2.3.2.1. Basic note entry
The basic mode of note entry is through the command prompt. 
2.3.2.1.1. Initiating note entry 
In the regular entry mode, note entry is initiated either by entering a command, or by listing a list of keywords. 



2.3.2.1.1.1. Commands for initiating note entry
The following commands initiate note entry:
ent, enter, +    		| To enter a regular note in the next available position.
enternext, ++ 		| To enter the sibling of the last note.
ent, enter, +  /$  	| To enter a  sibling of the last note
ent, enter, +  /&  	| To enter a child of the last note
enterchild, +++ 	| To enter the child of the last note
enterback, -        	| To enter a sibling of the parent of the last note.
2.3.2.1.1.1.1 Syntax of note entry
If the command is entered alone, then ARCADES will initiate the note inputter. It will not solicit an index value, but rather will automatically assign the index.
 
PLATE 2.25: Entering a note.
If an index is entered as the first value, ARCADES will initiate the note inputter, adding a note at the first available index, or the first available child or sibling of the index that had been entered. If a key or list of keys is entered in the first value, ARCADES will add an empty note—a note with an empty text-string---together with theses keys.
If a key or list of keys is entered in the first value, and a second value is also added, then ARCADES will add new note with the given keys and text. Use a vertical line (|) --- an EOL --- to mark the end of the line. 
Finally: if an index is entered in the first value, key(s) in the second value, and text in the third, ARCADES will add a new note with the given keys and text at the index, or first available index position, as per the rules above.
2.3.2.1.1.1.1.1 Rules for finding the first available index
The rules governing the determination of the first available index are a bit tricky, since, in the case of a child note, ARCADES searches for the first available sibling of the kind of note requested, rather than the first available new child. 
If, for example, you were to have notes at indexes 13, 13.1, 13.1.1, 13.1.1.1, 13.1.1.1.1, 13.1.1.1.1.1 and then add a child note at 13.1 with the command +++:13.1, the new note will appear at 13.1.2 – the first available sibling of the child of 13.1. If, however, you then add a sibling note at 13.1.1, the new note will appear at 13.1.3 – the first available sibling note of 13.1.1, since 13.1.2 is already occupied.
2.3.2.1.1.1.1.1.1 General modifiers for the enter commands
All of the entering commands permit the following 2 modifiers: /* and /+. 
The first of these, /*, is used to repress the show function.
The second of these, /?, is used to suppress the default keys.
2.3.2.1.1.1.2 Initiating entry with a list of keywords
It is also possible to initiate entry of a note simply by listing more than one keyword, separated by a comma. 
 
PLATE 2.26: Initiating note entry with a list of keywords.
2.3.2.1.1.2. Keyword querying
If keywords have not been entered, ARCADES will query the user for keywords to add, either before, or after, or both. To activate or deactivate querying either before or after text input, use the binary commands keysbefore and keysafter. It is also possible, in this way, to suspend keyword querying altogether. 
2.3.2.1.2. Entering the note text
When note entry has been initiated, ARCADES will display the list of commands for the inputter and the formatting codes. If you do not wish to see the list commands and/or formatting codes each time, you can use the binary enterhelp and formathelp commands. If the querying for keywords before text entry has not yet been suspended, then it will ask for keywords.  After entering a list of keywords, and pressing return, you will see seven POUNDS followed by a long line and terminating in a short vertical line. This indicates the size of the note, and will vary accordingly. Immediately below you will see PR 1, followed by a blinking cursor. “PR” indicates that you are in the prose-mode, which is the initial mode on activating the inputter, while the 1 indicates the line of text. 
 
PLATE 2.27: Entering and formatting help 
 
PLATE 2.28: Basic note entry. The line number increases by one each time return is pressed.
2.3.2.1.2.1 Input modes
ARCADES features two text input modes: prose, and poetry. It is possible to switch back and forth between these by inputting PERCENTAGE (%) + RETURN, to enter the prose mode, or the PERCENTAGE + PERCENTAGE + RETURN, to enter the poetry mode.
 
PLATE 2.29: Switching between prose and poetry modes.
2.3.2.1.2.1.1 The prose mode
The prose mode does not automatically insert an EOL character with each new line. It is still possible to insert a manual EOL character using one vertical stroke(|), or, in the prose mode, by inserting one or more spaces at the beginning of the line of text.
2.3.2.1.2.1.2. The poetry mode
The poetry mode automatically inserts an EOL character at the end of each line, thus preserving the integrity of the verse.  Whereas in the prose mode, the size of the note is arbitrary, and determined in advanced, the poetry mode sizes the note based on the longest line of text. It is possible to combine poetry and prose in the same note, but, so long as prose is selected once, then the size of the note will be determined “poetically” rather than “prosaically.”
2.3.2.1.2.2. Inclusions 
2.3.2.1.2.2.1. Including keywords in the text
If words or phrases included in the text are enclosed in curly brackets, then ARCADES will give you the option of adding them to the keywords associated with the note.  
2.3.2.1.2.2.2. Including text files
Text files can be inserted into the body of note by entering the name of the file in double curly brackets with the prefix AT (@) or STAR (*).  Depending on whether the prefix is an AT or STAR, 
ARCADES will seek the file in the folder “/textfiles”  or “/attachments.”
For example:
	{{@textfile}}
	{{*attachment}}
When the note is displayed, the text from the file will automatically be included.
To enable or disable the automatic display of text, use the binary command showtext. 
2.3.2.1.2.2.3. Including a JPEG image. 
A jpeg (.jpg) file can be included in the body of the note by surrounding it with double curly brackets and using a CARET (^) as a prefix:
	{{^picture}}
When the note is  displayed, the jpeg file will be opened. It must be closed manually.
To enable or disable the automatic display of images, use the binary command ¬showimages.
2.3.2.1.2.3. Terminating the note.
Two VERTICAL STROKES (|)  placed at the end of the line will terminate the text input. It is also possible to terminate text input by pressing return a certain number of times in succession. Use the binary returnquit command to activate or deactivate this option, and use the setreturnquit command to set the number of returns needed to automatically quit.
By combining automatic initiation of note entry with automatic termination of the text inputter, it is possible to enter a note using only the return key. 
2.3.2.1.2.4. Spelling 
ARCADES includes a basic spell-checker, explained in section 2.16. If there are misspelled words, the spelling corrector will be activated automatically. To deactivate or activate the spelling feature, use the binary spelling command.
2.3.2.1.2.5. Cutting and pasting text into the text inputter
It is possible to quickly enter text by copying it from another source, and pasting it in to the text inputter at the curser prompt.  If you wish to paste a poem, make sure to switch to the poetry mode; otherwise the lines will run into each other.
 
PLATE 2.30: Entering a poem in the poetry mode.



 
PLATE 2.31: The prose mode.
 
PLATE 2.32: Changing the size of a note.
2.3.2.1.2.6. Advanced keyword entry modes.
ARCADES also offers two advanced entry modes, which make it possible to avoid the separate keyword entry, and entering the entire note as a single text, with all the keywords and sequences extracted from this. 
2.3.2.1.2.6.1. The fromtext mode.
The fromtext command activates the fromtext mode, which automatically suspects the separate keyword prompt. The fromtext mode applies rules to parse the entered text, following the following rules.
(1) The text is divided into segments, each of which is surrounded by LMARK and RMARK.
(2) Each segment consists in an IDENTIFIER and a sequence of VALUES. 
(3) The IDENTIFIER is separated from the VALUES by MARK2.
(4) Each value in the list of VALUES is separated by MARK2.
(5) The followed reserved IDENTIFIERS are used:
	text | Used to indicate the main text of a note
	keywords | Used for non-sequence keywords, which may include tags and knowledge.
(6) All other VALUES will be interpreted as sequences. But if date is included in its name, then it will define a date sequence, and, likewise, is index is in its name, an index sequence.
LMARK, RMARK, MARK1, MARK2 are preset to EOL, EOL, COLIN, and COMMA. It is possible, however, to define new presets.  When EOL is used as a preset for LMARK/RMARK, then it is recommended that you enter the text in the poetry mode.
 
PLATE 2.32.1 Note entry in the fromtext mode.

 
PLATE 2.32.2 The result of fromtext entry.
2.3.2.1.2.6.1.1. Changing parsing presets
To create a new set of parsing presets, use newconvertmode. This will ask you for the name of the new mode. To define the presets, use convertdefinitions. To switch to an existing set of presets, use switchconvertmode. To show all available presets, use showallconvertmodes. When entering the divisor, you must add an UNDERLINE between the LMARK and the RMARK if the legnth of either term is greater than one character.
 
PLATE 2.32.2. Changing a convert definition.
2.3.2.1.2.6.1.  convertbyline
The command convertbyline offers a simpler alternative, a hybrid between regular entry and converting entry. It extracts keywords and sequence keywords, following above the rules, during line entry, and hence can be combined with the regular mode of keyword entry. 

2.3.2.1.2.6.1.2. Automatic activation of a convert mode during preset.
To activate a convert mode and apply it, simple include //MODENAME// in the body of the text, preferably at the head.
	
2.3.2.1.3 Editing a note 
ARCADES does not presently include an integrated text inputter and editor. Yet it is possible to edit, subsequent to entry, either the keys of a note, the text of the note, or both. 
The commands for initiating editing are: editnote, editnotekeys, editnotetext. These are followed by an index or a collection of indexes.  The command editnote accepts a single modifier /$, which is used to activate the “annotate” mode. Whereas editnote edits both the keywords and the text of a note, editnotekeys or editnotetext can be used to edit only the keys or only the text.
2.3.2.1.3.1. Editing the text of a note
When the text editing function is initiated, either by editnotetext or editnote, then ARCADES shows the instructions for editing the note, and displays “$1” followed by the first line of text in the original note, a vertical slash (|), and the blinking cursor. 
The basic process of editing proceeds by pressing RETURN to skip over a line if you want to keep it as it was, retyping new text, or entering a single DASH to delete an entire line. If you enter a double DASH followed by RETURN, then the rest of the note, beginning with the given line, will be deleted. 
	(1) RETURN : keeps the current line 
	(2) TEXT : replaces the current line with TEXT.
	(3) DASH : deletes the current line
	(4) DASH + DASH: deletes all subsequent lines
It is also possible to add new lines into the note by using the following functions.
(1) PLUS + RETURN : inserts new lines prior to the current line.
(2) CARET +RETURN : replaces the current line with a series of new lines.
	(3) DOLLAR + TEXT : adds text before the current line 
	(4) POUND + TEXT : adds text after the current line.
The PLUS and CARET commands call up the insert inputter, displaying “+1” at first, and incrementing the value for each subsequent line. To exit the insert editor, simply enter RETURN.
Note that pressing RETURN repeatedly, after initiating editing, will leave the note unchanged.

 
PLATE 2.33: Editing a note
2.3.2.1.3.1.1. editdelete
The binary command editdelete prevents ARCADES from keeping a copy of the deleted note. 
2.3.2.1.3.2. The “annotate” mode
The “annotate” mode can be used to add an annotation on the side of a note. The “annotate” mode is activated by using the modifier /$ with editnote, and then placing an underline mark (_) before the comment to be added to the side.


 
PLATE 2.34: Appending text before and after while using the editor.
  
PLATE 2.35: Deleting and changing lines with the note editor.
 
PLATE 2.36: Adding annotations to the note with the note editor.

 
PLATE 2.37: Display of a note with annotations
2.3.2.2. Modes of note entry
Several different modes of note entry are available through the terminal. The most basic mode, described above, initiates either with an explicit command or with a list of keywords. 
The second mode – called the “con-mode,” automatically initiates a new note whenever RETURN is entered, if no other command or text proceeds it. This mode is activated by the connext or conchild command, and is deactivated by entering a double semicolon (;;). If you use the connext command, the next index will be a sibling of the current index. For example: 1=>2, 1.1=>1.2, 1.1.5=>1.1.6, The conchild command, in contrast, will produce a child of the current index; for example, 1=>1.1,1.1=>1.1.1,1.7.19=1.7.19.1.
The third mode, the “quick” mode, allows you to directly enter a note in the form of the command, with the list of keywords coming before the COLON and the text of the note coming after.
Neither the “quick” mode nor the “con” mode prevents you from entering regular commands. 
2.3.2.3. Undo and redo
ARCADES keeps track of actions involves entering, deleting, and moving notes. To reverse an action that has been performed, use the command undo. To restore a command that has been undone, use redo. 
The undo and redo commands are limited to actions that involve entering, moving, and deleting notes. 
 
PLATE 2.38: The “conchild” entry mode.
 
PLATE 2.39: The “quick” entry mode.
2.3.3. NOTE AND NOTESCRIPT 
The most fundamental principle of ARCADES is the convertability of note and notescript. Every note, or collection of notes, can be exported as a user-readable notescript, and these can in turn be imported and converted back into notes. This not only makes it possible to exchange notes with other users, but also makes the process of notetaking independent from the software. It is possible, indeed, by marking up an existing text, to convert it into notes. And it is also possible to record notes using a simple text editor or word processor, or even to automate the generation of notes. Finally, the notescript codes can be included in the text of notes entered through the system, allowing, in effect, for the embedding of one note within another. 
2.3.3.1. Notescript formatting codes 
When ARCADES reads a notescript, it extracts all the elements of the text that begin with a left arrow bracket (<) and ends with a right arrow bracket (>). 
These extracted elements constitute notephrases. Notephrases are interpreted according to the initial element immediately following the bracket.
If the notephrase begins with DOLLAR ($), PLUS (+), DASH (-), then it modifies the keywords.
Dollar, followed by a list of keys, resets the keywords.
PLUS, followed by a list of keys, adds new keywords.
DASH deletes the last keyword from the list of keywords.
If the notephrase begins with AT+ INDEX  + AT,  a DOUBLE APOSTROPHE (“), a SINGLE APOSTROPHER (‘), a CARET (^), a SEMICOLON (;), or no special symbol, then it adds a note with the given keywords, and with the text following these special marks. 
AT+ INDEX + AT| Adds TEXT at INDEX
	SINGLE APOSTROPHE + TEXT | Adds TEXT at a sibling index.
	DOUBLE APOSTROPHE + TEXT | Adds TEXT at a child index.
	SEMICOLONE + TEXT | Adds TEXT at the previous letter.
Finally, a note beginning with STAR (*), adds a complete note, with keywords and text. The keywords and the text are separated by a semicolon. 
 
PLATE 2.40: Entering embedded notes.

2.3.3.2. Embedded notes 
A Notescript can be embedded in the text entered through the text inputter. While a reasonably long notescript can be entered this way, it is not recommended. This feature can also be used to input an impromptu note while composing another note.
2.3.3.3. Reading in notescripts with loadtext
For longer notescripts, it is recommended to use the loadtext command. If no file is entered after the colon, then it will call up the menu. 
The command loadtext accepts one value, and three modifies: /$, /&, and /*
The value identifies the name of a file to be loaded, whereas the modifier /$ is used to suppress the inclusion of default keys, /& is used to include a project, and /* to only load the project, and not the notes.
 
PLATE 2.41: Automatically loading and parsing text.

2.3.3.3.1. Outputting notescripts with formout
The command formout generates and saves a notescript.
It accepts four values: the collection of indexes to be converted, the filename, and Boolean values to indicate if the metadata and indexes are to be included. These last values can also be indicated, respectively, with the modifiers /$ and /&. You will also be asked if you wish to include the “projects” in output.
2.4. THE NOTEBOOK 
A notebook consists of a collection of notes with unique indexes. It is impossible to assign two different notes to the same index, but beyond this there are no restrictions on the indexes that are permitted. They could, for example, all have values between 1 and 2, or start with 20000. It is also not necessary that any of the notes be of size 0, or that parents exist for children, or older siblings for younger. 
*2.4.1 The data structure of the notebook
2.4.2. Basic organizational principles
2.4.2.1. Fields 
Fields, explained above (2.3.1.1.1) may be used to structure the notebook as a whole by dividing it up into different regions.
2.4.2.2.  Marked notes
ARCADES keeps track of marked notes, and allows the indexes of marked notes to be used as the value of command. 
To mark an individual note at the current location, use the command left bracket ([]. To unmark an individual note, use the command right bracket (]).
It is also possible to mark notes as a group by using the command addmarks, unmark notes using deletemarks, clear all the marks with clearmarks, and, finally, marked to display all the indexes of marked notes.
2.5. MOVING THROUGH THE NOTES
When the con-mode is not activated, Notescript will move through the notes whenever you press RETURN. This function is, however, automatically suspended whenever you enter a note, either until you press RETURN, or enter a command, ten times in succession, or enter a backslash (/).
There are two basic modes of moving through the notes: iteration and branching.
Iteration involves moving, according to a rule, through the indexes contained in an iterator-sequence.
Branching involves moving to a note that is related to the current note.
The flashmode allows you to flip through a stack of multi-sided  flashcards.
2.5.1. Iteration mode
The behavior of ARCADES in the iteration mode depends on two things: 
	1) The “rule” determining movement. (The iteration-rule)
	2) The content of the iterator-sequence.  (The iteration-content)
ARCADES defaults to the iteration mode, with the iteration-content comprising all positive-valued indexes, regardless of their size, and the iterator-rule consisting in moving to the note whose index is the “closest” index greater than the current index. 
 
PLATE 2.42: Moving through notes in the iteration mode.

2.5.1.1. The iteration rule
2.5.1.1.1. Regular iteration
In the regular mode of iteration, Notescript advances either backwards or forwards, and by either one index or more than one index. The behavior of the regular mode is thus determined by the direction,  speed, tilt, and depth. The direction defaults to forward, moving to a greater index value, and the speed defaults to one, advancing to the first closest index. The tilt determines whether it advances to parents/children, older or young siblings, or is neutral, and defaults to the neutral mode.The fourth factor determining the behavior of the regular iteration mode is the depth, which defaults to 0. 
2.5.1.1.1.1 Changing direction
The commands for changing direction are the left arrow bracket (<) to move backwards, and right arrow bracket (>) to move forwards.
*2.5.1.1.1.2. Changing speed
This feature does not yet exist, but may be added.
2.5.1.1.1.3. Changing depth
If the depth is 0, then the iterator iterates over notes with indexes of any size; if it is greater than 0, then it only iterates over notes whose indexes are less than the depth.
The depth can be set directly with the command depth. It can also be increased or decreased with deeper or shallower.
*2.5.1.1.1.4. Changing tilt
This function needs to be developed.
2.5.1.1.2 Random iteration
In the random mode, ARCADES advances randomly (pseudo-randomly, that is) through the indexes in the iterator-sequence until it has passed through all of them. Use the randomon to activate the random mode, and randomoff to deactivate it.
2.5.1.2. The iteration-sequence
The iteration-sequence defaults to all the notes with positive values, but it is also possible to iterate over a subset of the notebook. This is done by redefining the flipbook; whenever the flipbook is redefined, then the iterator-sequence is automatically reset. 
2.5.1.2.1. “Flipping out” search results
The binary flipout command activates the flipout-mode. When then flipout-mode is activated, then the results of searches are sent to the flipbook, which is reset accordingly.
2.5.1.2.2. Manually changing the flipbook
The flipbook can also be manually set by using the flipbook command. The flipbook command can accept as a value either a collection of indexes, or a list of fields. If entered as a simple command, without any value, then flipbook resets the flipbook to all the positive indexes in the notebook. 
2.5.1.2.3. Refeeding to the flipbook
It is possible to feed the results of other commands, provided that they yield a collection of indexes.
Here are some examples of valid commands:
(1) marked =>flipbook:?            | Feeds the marked notes into the flipbook.
                                                   | Equivalent to flipbook:[?]

(2) search:VALUE=>flipbook:? | Feeds a search result into the flipbook.
   | Equivalent of “flipping out” a search
   | Also equivalent to flipbook.		
2.5.1.2.4 Descendants
Because ARCADES allows for hierarchical structures, you may wish to reset the sequence-iterator not to a group of notes defined by a range of indexes, but to all the descendants of a given index. This can be achieved with the descendants command. When this command is used, it not only resets the flipbook, but it also indicates the value that has been entered after the command prompt. It will now be possible to enter this value, which all the indexes in the flipbook start with, simply by using a single period.
To restore the sequence-iterator to all the indexes in the notebook, enter descendants without a value.
2.5.1.2.5. Advanced functions
There are two additional advanced flipbook functions which will be discussed in the context of advanced features. These include: flipproject (see section 2.9), which sends the indexes in the current project to the sequence-iterator, and the cluster function (see section 2.8.4.) 
2.5.1.2.6. Manual operation of the iterator
In the iterator-mode, ARCADES always advances to the “next” note according to the direction, speed, and rule, and the content of the iterator sequence itself. It is, however, also possible to navigate manually through the iterator-sequence with the following commands. 
	(1) period | moves forward one index
(2) comma | moves back one index
	(3) period*N  | moves forward by N indexes
e.g.   ……. | moves forward by 7 indexes
	(4) comma*N | moves back N by indexes
		e.g. ,,,, | moves back by 4 indexes
	(5) first | goes to the first note in the iterator sequence
	(6) last | goes to the last note in the iterator sequence
	(7) hop:N | moves forward by N indexes
		e.g. hop:5 | moves forward by 5 indexes
 
PLATE 2.43: Jumping down a note with descendents.
 
PLATE 2.44: Moving through the notes in the “random” mode.
 
PLATE 2.45: Flipping out a search.
2.5.2. Branching mode
Those of us who grew up with personal computers in the 80s may remember a simple text-based game where you chase a monster through a labyrinth of caves connected to each other through passageways. This game, a simple application of graph-theory, indicates a powerful way of thinking of the organization of a notebook. Up until this point we’ve been considering a notebook primarily as a collection of notes identified through indexes, where the relations of these notes to one another is entirely a function of the relation of their indexes. As different as the various modes of iteration are from one another, they all share in common this way of conceiving of what a notebook is. The iterator-sequence is a collection of indexes, and moving through the notes means moving through the indexes. But it is also possible to think of notes as relating to other notes through their own content; this content includes every attribute of the note – its keywords, its text, its metadata, and also its index value. From such a perspective, indeed, the iterating mode may itself be seen as a special case of this second, and more general organizational logic. Because each note has only one index, and because all indexes form a well-ordered series, it becomes possible, by abstracting away from all other attributes of the note, to precisely define a collection of indexes and a rule (even if only the “rule” of randomness) governing the movement through them. But this is in turn limiting: not least of all, it restricts the organizing principle to what has been established, in advanced, by the user.
Once you consider notes as related by their content, it then becomes possible to conceive of having a multitude of different affinities. These include affinities which are:
	1) based on keywords, including links and other keywords.
	2) based on common words in the text.
	3) based on the date of composition.
The branching mode implements an organizational logic based on these different kinds of affinities. It allows you, in other words, to move from one note to another note chosen from among a set of the notes to which it has affinities according to a well-defined rule. We might indeed distinguish between affine notes and kindred notes. Kindred notes are related by their respective indexes– and indeed, as explained above, all notes within a notebook have some kind of kinship between them.  Affine notes are related by their respective attributes. Strictly affine notes involve an affinity that is not simple kinship – that doesn’t involve just the index value. If notes are strictly affine, then their affinity remains the same even if they are moved to different locations. Hence, links, even though expressed through indexes, in fact involve a strict affinity, since the link is actually merely a “pointer” to the transposition table.
2.5.2.1. Using the branching mode
To activate or deactivate the branching mode, use the binary iteratemode command.
Use the commands branchone, branchtwo, and branchthree to select between the different branching modes.


2.5.2.1.1. The first branching mode
The first branching mode moves randomly to notes that have related keywords.
2.5.2.1.2. The second branching mode
The second branching mode moves randomly to related links.
2.5.2.1.3. The third branching mode
The third branching mode allows you to move by choice through links.
*2.5.2.1.4. Other possible branching modes
There are many other possible branching modes which might be implemented. These include:
1) Distinguishing between keyword affinities according to keyword frequency, with greater value assigned to less frequent keywords.
2) Identifying affinities in the text.
2.5.3. The flashmode
Unlike the previous two modes, the flashmode only works on a special type of note: a “flashcard” note.  The flashmode, which is available only in the iteration mode, allows you to flip over the sides of such flashcard notes. 
2.5.3. Flashcards
Flashcards are made by entering in an ordinary note, using /FC/ to separate the sides. If /FC/ appears twice in the note, for example, then the note will have three sides.
For example:
	<man /FC/ der Mensch /FC/ l’homme /FC/ il uomo> 
| Defines a 4 sided flashcard with the English, German, French, and Italian words for “man”
2.4.4. Entering the flashmode
The binary command flashmode is used to enter or exit the flashmode. In addition to this, you will also need to set the number of sides of the flashcard by using the command setsides, which defaults to two. To adjust when the flashcards advance, and which card they start with, use setflipat. 
When the flashmode is activated, ARCADES will advance through the sides of each note before moving on to the text note in the iterator.

 
PLATE 2.46: Flashcards
The flashmode operates within the iterator mode, and all the regular features of the iterator mode remain the same as before. All the flashmode does, indeed, is add an additional requirement that must be fulfilled before the iterator advances.
2.4.6. Using flashcards outside the flashmode
The use of the following commands do not require that the flashmode is activated.
	(1) noflash | disables the display of flashcards

	(2)  flashforward, ff | advances to the next side
	(3) flashback, fb | goes back to previous side
	(4) flashreset, fr | returns to the first side
	(5) flashto, ft | goes to a specific side 
The numeration of sides begins with 0.

2.5.4 Interaction of iteration and note entry
The interaction between the iterator and note entry is subtle, and may take some getting used to. It is important to keep in mind, first of all, that while the iteration is confined to the notes whose indexes are included in the iterator-sequence, notes from throughout the notebook can be displayed, and accessed, and notes can be added anywhere. Ordinarily, the index position at which a new note will be added is determined by the iterator as it passes through the iterator sequence, but this is not always the case. 
2.5.4.1. Displaying a single index
Any index can be entered as a command. If a note with the index is present in the notebook, then this note will be displayed. Doing this, however, will not affect either the position of the iterator, or the position at which  new note will be added.
2.5.4.2. The effect of adding notes on the iterator-sequence
If you add new notes to the notebook, these will be automatically added to the iterator-sequence.
2.5.4.3. Skipping
By entering the command skip:INDEX, you can skip to the note at INDEX. This INDEX will the become the position for entering a new note.
 *There are some oddities in the behavior of this function which need to be resolved.


 
PLATE 2.47: Temporarily exiting the iterator sequence.
 
PLATE 2.48: Newly entered note added to the iterator sequence.

 
2.6. DISPLAYING 
ARCADES offers three different modes of displaying the notes in the notebook. The first, called the “sequential” mode, displays individual notes--or kindred groups of notes-- individually as you move through the notebook. The second, the “list” mode, displays multiple notes in a list allowing you to scroll backwards or forwards. The third, the “multi” mode, many notes simultaneously as a tiled sheet. 
2.6.1. The sequential display method 
As you either progress through the indexes of the notebook, or enter in indexes directly as commands, ARCADES displays them, either alone, or together with the cluster of notes that belong, together with it, to the tribe of the top level note. 
The behavior of the sequential display mode is determined with the following commands: childrentoo, fulltop, and automulti. 
2.6.1.1. Modifying the sequential display method: childrentoo
In its default “childrentoo” mode, ARCADES displays the current note together with the entire tribe of notes belonging to the top-level note with which it is associated. The binary childrentoo command can be used to have ARCADES no longer show the tribe together with the note.
*The interaction of depth, deeper, and shallower with the childrentoo command is a bit quirky. When the depth is set at 1, the tribe is repressed, but otherwise the complete tribe is displayed, despite the fact that only numbers of size less than the depth will be iterated over.

 
PLATE 2.49: Displaying a note with its children.


 
PLATE 2.50: Displaying the children notes separately.
2.6.1.2. Modifying the sequential display method: fulltop
When the “childrentoo” mode is deactivated, then, if the “fulltop” mode is activated, ARCADES will only display the tribe of top-level notes. Other notes with be displayed alone.
2.6.1.3. Modifying the sequential display method: automulti
When the “automulti” mode is activated together with the “childrentoo” or “fulltop”-modes, then Norescription will display the tribe as a tiled sheet. 
 
PLATE 2.51: “Automulti” mode.
2.6.1.4. The representation of hierarchy through the variable left margin
When displayed either individually or as part of a tribe, so long as the “automulti”-mode is suspended, notes are indented in order to indicate the size of their index. 
The degree of identation can be adjusted using the command indentmultiplier.
 
PLATE 2.52: The vertical lines on the left indicate depth by multiples of 5
2.6.2. The notebook display mode
Various commands are available to display a large number of notes either as a list of full-length notes or of notes in the compressed “short”-form. 
2.6.2.1. The all command
The all command can be used to display all the notes in the notebook. If your notebook contains many notes, it may take a bit of time to run the first time it is used, but it saves the results to a buffer which may be retrieved subsequently.
The all command operates in two modes: the “quick” mode, to which ARCADES defaults, achieves a quicker speed by circumventing a call to the display.noteprint function, but sacrifices flexibility in the output. The “regular” mode is more flexible, but slower. Whereas the “quick” mode outputs to the “all”-buffer, the regular mode outputs to the “display”-buffer.
The /$ modifier selects the “regular” mode.
In the “quick” mode, all can be restricted to a certain index range, with %%INDEXFROM-INDEXTO. Keep in mind, though, that this will overwrite the “all”-buffer.
In the regular mode, all, in addition to being restricted to a certain index range, accepts a single value and several modifiers. The optional value indicates the size of the indexes to be listed; all indexes must be less than this value. If no value is listed, then notes with indexes are all sizes will be displayed.
Modifiers include: /& /? /=
	1) /& Excludes non top-level notes.
2) /*  Excludes square characters around notes – allowing format to be outputted in a form that can be copied into other programs.
3) /?  Suspends the automatic short mode
4) /= Includes dates with the notes
2.6.2.1.1 Displaying the “all”-buffer
The “all”-buffer, to which the “quick”-mode outputs, can be presented by entering a double DOLLAR. ($$)
2.6.2.1.2. Displaying the “display”-buffer
The “display”-buffer, to which the “regular”-mode outputs, can be presented by entering a single DOLLAR ($). 
2.6.2.1.3. Scrolling through the notes
If many notes are listed, they will not be shown all at once, but will be presented through a menu that allows you to scroll back and forth between them.
If you do want to list all notes, press A[ll], while to change the number of entries shown, press C[hange]; the arrow keys advance forward and backward, while double arrows go to the first or last page of entries. [Q]uit returns to the command prompt.
2.6.2.2. The show command
The show command is identical to the all command, except that it does not have a “quick”-mode. It accepts one value: the collection of indexes to be shown.  
PLATE 2.53. A list of indexes



 2.5.2.3. The inc command
The inc command shows the notes in the immediate vicinity of the current index.
While inc is a bit slower than presenting an already-constituted list of indexes, it is much quicker than constituting all the indexes from scratch, and it also automatically reflects all modifications to the notebook. 
 
PLATE 2.54: Incremental display of notes.
2.6.3. The multi display mode
The “multi” mode fits notes together into a “sheet,” according to their width. The notes are placed in a stack, with the largest possible note that can fit in the free area withdrawn from the stack.  The output of the multi display is stored under a user-defined name, and can also be saved as a text file.
2.6.3.1. The multi command
The syntax consists in four values, and three modifiers:
	multi:INDEX COLLECTION;DISPLAY STREAM;WIDTH;SAVE STREAM  /* /? /=
The first value indicates the indexes to be displayed; the second the name of the “stream” to which display will be outputted, and the third the width, in characters, of the display.
The /$ modifier shows notes in a uniformly small size, as defined using the command smallsize.
The /* modifier is used to activate the “vary”-mode, adjusting the size of the notes according to the length of the text string.
The /? pauses the display after each line.
The /= saves the output to a textfile, using either the name of the display stream or name entered as value 4. 
2.6.3.2. Streams
To list all the active streams, enters streams.
To display an active stream, enter showstream:STREAM
The /? modifier can be used to pause.
To delete an active stream: enter deletestream:STREAM.
2.7 MANIPULATING THE NOTEBOOK
A notebook, as mentioned, consists of a collection of notes with unique indexes. It is possible, using relatively simple commands, to reorganize the notes, move them to different index locations, create copies of them, merge notes together, and delete them.
*2.7.1. The basic program structure 
The program architecture of ARCADES has been designed in such a way that all basic operations on the notes are handled by two methods: addnew  and move. Notes are “deleted” by moving them to the negative indexes, though it is also possible to permanently delete motes through a third core method, delete, this need not be used. 
Although this organization principle makes it easy to expand ARCADES while preventing subtle bugs from emerging, it comes at the cost of speed. Moving many notes to another location can take some time, and is not recommended. 
2.7.2. Overview of commands for manipulating the notebook
Commands for manipulating the notebook may be divided into three categories:
1)  Those which only affect the relation of the note to the index.
 | These “index” commands include: delete, move, copy, clear, purge, rehome,           
 | eliminateblanks.     
2) Those which change the “content” and “properties” of notes without changing indexes.
 | These “content” commands include: correctkeys, reform, 

3) Those which change both the “content” of notes – the keywords and text –as well as the relation of this content to indexes.
 | These “note” commands include: revise, mergemany, conflate, split, sidenote
 
PLATE 2.55: Multiple display with smaller notes.
 
PLATE 2.56: Multiple display with larger notes.

2.7.2.1. “Index” commands
2.7.2.1.1. delete
Entering delete, or alternatively del, with a collection of notes as a value, deletes these notes by moving them to a negative index positions. 
PLATE 2.57: Deleting a range of indexes.
2.7.2.1.2. clear
The clear command is used to delete all the notes from the notebook by moving them to negative index locations. 
Because it is rather dangerous to use, it queries you each at step to see if you want to continue.
There is little reason for using clear accepts when working with very small notebooks
 
PLATE 2.58: Clearing deleted notes.
2.7.2.1.2.1. The undel command
The command undel is used to “undelete” the notes with negative indexes, moving them back into positive registers.
2.7.2.1.3. compress
The compress command “compresses” the notebook by moving all the notes to contiguous index positions.
 
PLATE 2.59: Using the compress command.
 
PLATE 2.60: Rehoming orphaned notes.

2.7.2.1.4. rehome
The rehome command is similar to compress, but moves notes in such a way as to eliminate orphan notes. The rehome command accepts as a value a collection of notes.
2.7.2.1.5. move
The move command allows you not only to move  individual notes from one index location to another, but also to move collections of indexes and even transform the hierarchical structure of the notebook itself. 
The syntax of the move command is as follows:
	move:INDEXESFROM;INDEXTO;[S/M/C];[yes/no]   /$ /& /* /? /=
The first value indicates the collection of indexes that will be moved; the second the destination to which they will be moved; the third – either S, M or C indicated how the how the notes will be organized at the destination; and the fourth value whether the children of indexes will be included.
The first of the three modifiers are to indicate the third value, while the fourth and fifth are used for the fourth value. Thus: 
(1) /$ ≈ (is equivalent to) S  ≈ Subordinate the indexes under the destination index, preserving the hierarching structure of the source collection.
(2) /& ≈ M ≈ Make the indexes “compact” (“compressed”) under the destination index,  so that whatever hierarchical structure they have is eliminated. Whatever their structure in the source was, they will be turned into a series of siblings.
(3) /*  ≈ C ≈ Organize the indexes as a series of “children” in the destination range.
(4) /? ≈ yes ≈ exclude “child” indexes from the source range.
(5) /= ≈ no ≈ don’t exclude “child” indexes
It is important to note that the behavior of S/M/C depends on whether the destination range is already occupied. If there is an index in the destination, then the new notes will be placed in a subordinating relation – either (S), which creates a “microcosmic representation” of the source range subordinated to destination index, or (M), which flattens them into siblings, children of the same index; or (C), which turns them into a chain of children.
Observe, also, that ARCADES does not forbid you from moving the source range into itself, nor can this “crash” the system. This is because notes are moved individually, the interpretation of each “move” depends on the present state of the system after an individual move, and ARCADES will either refuse to execute a move (if the source index is empty) or will interpret it such that it can be done (if the destination is occupied). For this reason, though, it may be a bit tricky to foresee how a command will be executed when it moves indexes onto themselves.
  
PLATE 2.61: A simple use of the move command.
 
PLATE 2.62: Moving with “make compact.”
 
PLATE 2.-63: Moving with “subordinate”.
 
PLATE 2.64: Notice how the order gets mixed up.

 
PLATE 2.65:Moving from one range into another range.


2.7.2.1.6. copy
The copy command is identical to the move command, save that it does not delete the note from the source index.
2.7.2.1.7. Permanently deleting notes
The command permdel is used to permanently delete all the notes with negative indexes.
2.7.2.1.8. Showing notes with negative indexes
To see the notes with negative indexes – the temporarily deleted notes – use the command showdel.
2.7.2.2. “Content” commands
2.7.2.2.1. correctkeys
The command correctkeys is used to change the keys that are found over a collection of keys. It is important to note that it changes the keys globally, regardless of the scope of the collection.  It accepts only one value, the collection of indexes, and one modifier /$, which specifies whether it should only correct keys, or keys together with tags.
 
PLATE 2.66: Correcting keys I – Selecting keys to revise.

 
PLATE 2.67: Correcting keys II – Going through the selected keys.
 
PLATE 2.68: Correcting keys III – The final result.
2.7.2.2.2. reform
The command reform is used to correct the spelling and eliminate formatting errors across a collections of notes.
2.7.2.3. “Note” commands
2.7.2.3.1 revise
The command revise (alternate form: rev) is used to add to an existing note. It can either add the text of one existing note to another note, or call up the text inputter. The user can also define the text placed between the note, and whether the new text is placed before or after.
The revise command accepts three values and the modifiers /$ /& /* /?. The first value is used to select the index or collection of indexes to be revised, the second value is the index of the note to be added, and the third value is the text to be inserted between notes. 
The /$ modifier is used to add the new text to the beginning rather than the end.
The /& modifier adds the new text both the beginning and the end.
The /* modifier selects /BREAK/ as the “breaker”
The /? modifier selects /NEW/ as the “breaker”
2.7.2.3.2 mergemany
The command mergemany is used to take a collection of indexes, and join them together into a single index. It does not delete the indexes that is conflates, and hence it can be understood as a mode of copying.  It accepts three values and the modifiers /$ and /&.
The first value is the collection of indexes to be joined together. The second value is the destination in which the new index is to be placed. The third value is the manner in which the notes are to be joined together, and can be either (c)onflate or (e)mbed. The modifier /$ is the equivalent to the value (c)onflate while the modifier /& is the equivalent to the value (e)mbed. If you use both modifiers, it will repeat the action twice in each of the two manners.
The “embed” joins together displayed notes, together with brackets, whereas “conflate” merely combines the text of the notes and their keywords.
 
PLATE 2.69: Merging several notes together with mergemany in the “embed” mode.

 
PLATE 2.70: Merging several notes together with mergemany  in the “conflate” mode.
2.7.2.3.3 conflate
The command conflate is similar to revise and mergmany. It joins a collection of notes together separated either by /BREAK/, /NEW/ or a user-defined term.
It accepts four values and the modifiers /$, /&, /*, and /?. The values consist in (1) the collection of the indexes of notes to be joined together the destination into which the newly created note is to be put, 3)  (e)mpty, (b)reak, or (n)ew, and 4) a user defined “breaker”.
The first three modifiers are equivalent, respectively, to (e)mpty, (b)reak,  and (n)ew, while /? Is used to solicit a user-defined “breaker.”
2.7.2.3.4 split
The split command can be used to split the text of an existing note, without adding in any special characters. It accepts four values: the index of the note to split, the number of columns, the width of columns, and the “breaking” character used to split the text into words. 
 
PLATE 2.71: Automatically splitting text with split (before).
 
PLATE 2.72: Automatically splitting text with split (before).
2.7.2.3.5. columns
The command column (alternative form: col) is used to convert a regular note into a note with columns. It can also be used to remove columns.
The columns command accepts two values, and the modifiers /$, /&, and /*.
The first value is the collection of indexes to convert to columns, while the second value is the character that is to be converted into the underline (_) mark distinguishing columns across the line. 
The modifier /$ can be selected to undo columns while  /& adds counters, and /* adds counters without converting to columns.
2.7.2.3.6. sidenote
The command sidenote can be used to take a collection of indexes and merges them together as a series of columns.
It accepts two values, and the single modifier /$. 
The first value indicates a collection of indexes, and the second value the width of the columns. The modifier /$ is used to add counters.
 
PLATE 2.73: Merging notes into columns with sidenote.

2.8 REPRESENTING THE NOTEBOOK
In addition to simply displaying notes, either singly or en masse, ARCADES offers various more sophisticated methods for representing the content of a notebook. 
2.8.1 Searching 
The Notescripton search function has been designed to be both versatile and fast, allowing you to search for a variety of different attributes of the note, distinguishing between keywords, words in the text, tags and even metatags (knowledge), and allowing for great logical expressiveness, with nestled parentheses, and the three basic logical operations (AND, OR, NOT).  It can also be used to search over sequences, allowing you, for example, to find all the pages within a certain range in a certain text, or limit the search for a keyword accordingly.
*2.8.1.1. Implementation of the search function
2.8.1.1.1.The use of the eval function
The search function leverages the Python parser by using an eval function. The danger of this use of the eval function, however, is slight, since the eval is only run on “reduced” expressions, consisting only of sets or indexes and the logical functions joining them.
2.8.1.1.2 Data structure
The speed of the search function is achieved by using dictionaries to keep track of all searchable terms rather than searching directly over the notes themselves. Separate dictionaries are reserved for words in text, keywords, tags. These dictionaries are not kept in the shelf, but in the pickled default file. This allows them to be reconstituted if they become corrupted. 
When opening a notebook, you have the option of reconstituting the word dictionary. And it is also possible to do it at any subsequent point by using the refresh command.
2.8.1.2. Using the search function
2.8.1.2.1. Calling the search function
The search function can be initiated using either the search command, or a single question mark (?) as the abbreviated form. 
If you are refeeding results from another command into a search, it may be necessary to avoid the abbreviated form, since the question mark is also used as the placeholder for previous result.
The search command accepts one value, the search phrase, as well as four modifiers.
These are:
	(1) /$ 	| shows notes resulting from the search.
	(2) /& 	| shows the results of the search organized by date
	(3) /* 	| Overrides the deletion of the already constituted date-dictionary of the keys
	(4) /? 	| Includes indexes in the date dictionary
The third and fourth modifier depend on the use of the second.
2.8.1.2.2. The search phrase
The search phrase consists in three elements: terms, specifiers, and logical operators.
2.8.2.1.2.2.1. The term
Search terms consist in a single word. The search term is ordinarily case sensitive, unless it is written in all caps.
2.8.2.1.2.2.1.1. Wildcards
The star (*) can be used as a wildcard. 
For example:
	(1) *pig 	| searches for words ending in “pig.”
	(2) frog*	| searches for words beginning in “frog.”
	(3) *ab* 	| searches for any word containing “ab” 
	(4) a*b*c*d 	| searches for a word that starts with “a”, ends with “d”, 
			   and contains “b” and “c” in the middle in that order.
2.8.2.1.2.2.2. Specifiers
The following specifiers indicate whether the term is to be searched for in the text of the notes, among the keywords, among tags, or among the metatags (knowledge).
	(1) TERM 		| as word in the note text
	(2) <TERM> 		| as keyword
	(3) <#TERM> 	| as tag
	(4) <##TERM> 	| as metatag
2.8.2.1.2.2.3. Logical operators
The following logical operators can be used:
	(1)  vertical line (|) 	| OR
	(2) ampersand (&) 	| AND 
	(3) tilde (~) 	      	| NOT (used only before terms with their specifiers)
	(4) parentheses		| 


  
PLATE 2.74:: Searching for keywords, tags, metatags (knowledge), and text words. Notice the knowledge definition: animal=creature.
 
PLATE 2.75: Search with logical operators.
2.8.2. Histograms 
Histograms display a frequency chart for keywords or words in the text. To produce a histogram, simply use the histogram command, with a collection of indexes as the value. The modifier /$ is used to choose between text words and keywords.
2.8.3. Chronograms 
Notesccription allows you to represent the keys in a collection of notes by date and time of composition or modification. The chronogram feature is very flexible, and sorts according to year, month, day, or even hour, in various combinations. It also allows you to choose between using the first date, the newest date, or all the dates associated with the notes in the index range, and also reveal or suppress the indexes associates with the keys.
2.8.3.1. Initiating a chronogram
To initiate a chronogram, use the constdates (alternative form: constitutedates) command, which accepts three values and the modifiers /$,  /&,  /*  and /?.  The first value consists in a collection of indexes, the second value the determinant, and the third value in either f(irst), n(ewest), or a(ll). 
The modifiers /$ and /& can be used to define the determinant, respectively, as ym (year+month) or ymd (year+month+day) , in lieu of the second value. The modifier /* is used to show indexes, while /?  Explicitly ask which dates are to be used, and thus can be substituted for a third value.
Consider the following commands:
(1) constdates:1-100;ymd*h;f /*  
Create a date dictionary for indexes 1 to 100, with  ymd*h as the determinant, using the date when the note was first entered, and displaying indexes.
(2) constdates:1-1000;ym /? 
Create a date dictionary for indexes 1 to 1000, using ym as a determinant, and querying whether to use the first, newest, or all dates.

 
PLATE 2.76: A simple histogram. 


2.8.3.2. The determinant
The determinant indicates what divisions of time (year=y, month=m, day=d, hour=h, minute=m, second=s, microsecond=x) will be used to organize the date dictionary.
The maximum determinant is ymd*hmsx.  Any subset of the maximum determinant, with the star included, is a valid determinant. Hence valid determinants include:
*h, *hm, *hms, *hmsx, *hx, *m, *ms,  *mx, *s, *sx, *x, d, d*h, d*h, d*hm, d*hms, d*hmsx, d*hx, d*m, d*ms, d*mx, d*s, d*sx, d*x, m, m*h, m*h, m*hm, m*hms, m*hmsx, m*hx, m*m, m*ms, m*mx, m*s, m*sx, m*x, md, md*h, md*h, md*hm, md*hms, md*hmsx, md*hx, md*m, md*ms, md*mx, md*s, md*sx, md*x, y, y*h, y*h, y*hm, y*hms, y*hmsx, y*hx, y*m, y*ms, y*mx, y*s, y*sx, y*x, yd, yd*h, yd*h, yd*hm, yd*hms, yd*hmsx, yd*hx, yd*m, yd*ms, yd*mx, yd*s, yd*sx, yd*x, ym, ym*h, ym*h, ym*hm,  ym*hms, ym*hmsx, ym*hx, ym*m, ym*ms, ym*mx, ym*s, ym*sx, ym*x, ymd, ymd*h, ymd*h, ymd*hm, ymd*hms, ymd*hmsx, ymd*hx, ymd*m, ymd*ms, ymd*mx, ymd*s, ymd*sx, ymd*x  
Of course, not all of these are useful. 
2.8.3.2.1. Showing and setting the determinant
The determinant can always be entered explicitly when initiating a chronogram. If no determinant is indicated either through a value or a modifier, then ARCADES will use the default determinant.
The default determinant is preset to “ym” – year and month – but it can be changed by using the changedet command. 
The current determinant can be displayed with showdet. 
2.8.3.2.2. Displaying an existing chronogram
Chrongrams are stored in a dictionary using the determinant as key.  You can use the command showdatedict to display an existing chronogram. The accepts the determinant to be displayed as a value, and the modifiers /$, /&, /*, /?, /=, which can be used to add, respectively, year, month, day, hour, and minute.  The minute can only be added after an hour.
2.8.3.2.3. Purging keys from the chronogram
Because the chronogram displays keys, it may be desirable not to have it show every single key, since otherwise it will become excessively large and, consequently, not very useful. ARCADES thus allows you to display a chonogram with selected keywords, or types of keywords, purged from it. 





 
PLATE 2.77:  defaultnotebook:1   ?:Heidegger =>constdates:?;ymd
 
PLATE 2.78: defaultnotebook:4   ?:HUSSERL =>constdates:?;ymd*h /*
 
PLATE 2.79: ?:<HUSSERL> =>constdates:?;ymd /*   
2.8.3.2.3.1. Showing a purged chronogram
This is done using the showdatedictpurge command, which takes two values and the modifiers /$ /& /* and /?.
The first value is the determinant, which functions as with showdatedict. The second value is the purge sequence. The modifier /? Is used to query for a purge sequence. The syntax of the purge sequence is explained below. Keep in mind, however, that if the purge sequence is entered through showdatedict, then the modifiers cannot be used.
2.8.3.2.3.2. The purge sequence
With the setpurgekeys, it is possible to instruct ARCADES to purge specific categories of keys as well as certain individual keys. 
The command setpurgekeys accepts one value—a purge instruction-- and all five modifiers.
The purge instruction has the following syntax:
	SPEC|KEY1,KEY2,KEY3…
SPEC consists in one or several of the following symbols, each of which is equivalent to a modifier: 
a[ll caps]	|  /$
u[pper case]	|  /&
l[lower case]	|  /*
s[eqeunces]	|  /?
n[umbers] 	|  /=
KEY is a valid search phrases, and yields all the applicable keywords.
So for example: *a* would yield all the keywords containing “a” in the middle.
2.8.3.2.3.3. Other purge-related commands
The following related commands are also available:
 	clearpurekeys 	|  to clear all the purge keys.
	showpurgekeys | to show the purge keys
2.8.3.2.4. Displaying active determinants
You can use the command activedet or actdet to display the determinants for which chronograms currently exist. 
2.8.4. Clustering 
Clustering allows you to organize a collection of notes into groups with “connected” keywords. Keywords are “connected” if they either belong to the same note, or are both “connected” to a third note, with this definition applied recursively to yield an exhaustive system of “connections” for every note. The relation of “connection” is reflective, symmetrical, transitive, and substitutive. The system of “connections” is called a cluster, and every note within a cluster is connected with every other note within it. 
2.8.4.1 Monolithic and variegated notebooks
The usefulness of clustering depends on the structure of the notebook, and the keywords used. If keywords are assigned too liberally, than the clusters will become so large as too be useless. A notebook that clusters nicely is “variegated”; a notebook that clusters poorly is “monolithic.”

   
PLATE 2.80: The chronogram is first constituted using constdatedict, and then the chronogram is displayed purging lowercase keys.
  
PLATE 2.81: And then the same chronogram is displayed with capitalized and lowercase keywords purged, and then eliminating the keywords INSTITUTION and REAL ANIMAL.

In order to make monolithic notebooks seem less monolithic, and hence more amenable to clustering, ARCADES allows you to 1) use only a certain number of the least frequent keys and 2) purge keys from the keysets. These two operations can be combined. The reason for favoring the least frequent keys over the most frequent is obvious: the least frequent keys are more likely to be have a specific “differential” value in relation to other keys in the notebook, and hence to be semantically meaningful. 
2.8.4.2. Creating clusters
To cluster a collection of indexes, use the cluster command. The cluster command accepts two values, and the modifiers /$ and /&. The first value is the collection of notes which you wish to cluster, while the second value is the number of least-frequent keys you wish to use. If nothing is entered for the second value, then ARCADES will use all keyword. 
The modifiers have the following meaning:
	(1)  	/$ 	| “Iterates over” the cluster
	(2)	/& 	| To use the purge sequence defined for the chronogram (see 2.8.3.2.3.2)
2.8.4.3. The difference between the two purge functions
The main advantage of using the “native” purge function is to avoid having to redefine the chronogram purge function. But there also are slight differences in functionality. The “cluster” purge function is able to handle the German β, and it lacks the capacity to purge sequences and numbers, as these are unlikely to interfere with the clustering.
 
PLATE 2.82: Clustering 

2.8.4.4. Defining the “cluster” purge function
The purge function for clustering cannot be defined during a function call, but only by using the cpara command, which accepts one value – a subset of the string “acl,” according as you wish to purge all-cap words, capitalized words, or lower case words – and the modifiers /$, /&, and /*, which correspond, respectively, to these three different kinds of purges. Hence, to purge keywords that are in all caps, you could enter either:
	(1)	capara:a
	(2)	cpara /$
2.8.4.5. Iterator over clusters
If you use the /$ modifier while initiating clustering, then ARCADES will create a series of iterators corresponding to the clusters, making it possible to advance from iterator to iterator – from cluster to cluster, in other words – resetting the iterator each time. To advance to the next iterator, simply enter a semicolon (;). 
2.8.4.5.1. Killing clusters
The  killclusters command can be used to eliminate the clustered iterators.
2.9 PROJECTS 
ARCADES offer a simple yet powerful means of juggling multiple tasks while working in a single notebook. Say, for example, that you are simultaneously taking notes related to several different projects that you are working on. If you just add notes to your notebooks related to these various projects in whatever order you please, then, unless you invest a great deal of effort in keeping track of what is going on, you are likely to end up with a disorganized and largely useless notebook. Moreover, default keys will be pretty much useless, since they will have to be constantly changed, leading to errors – with the default keys carried over by accident to projects where they don’t belong. Hence, you will be forced to add the keywords with each new note, leading, in turn, to inconsistencies in the keyword assignment. On the other hand, however, if you just use separate notebooks for different projects, then you will forego the advantages of having notes from different projects brought together in the same place. You will not be able to perform global searches or establish links between different notes from different projects. Nor will you be able to glean and overarching view of how your different projects are evolving. 
2.9.1 The basic elements of a project
A “project” in ARCADES stores some basic information about the program-state and keeps track of the indexes of notes that have been added to the project. Finally, when a project has been activated and is in use, each new note will include, as sequence keyword, the name of the project together with a value indicating the order in which the note has been entered, with the initial value determined by the user.
Projects are stored in a special dictionary, which is a permanent attribute of the notebook. The name of the project serves as the identifying key. For each project, the following attributes are kept track of and stored:
	1) The default keys
	2) The current position in the notebook.
	3) The entry mode, such as “connext” or “conchild”
	4) A list of all the indexes that have been added to the notebook.
	5) The date when the project began.
	6) The date that it was last modified.
	7) Whether it is currently open.
2.9.2. Project commands
Commands for using projects include: newproject, saveproject, showprojects, resumeproject, loadproject, endproject, flipproject, crrrentproject, archiveproject, unarchiveproject, showarchivedrpojects, deletearchivedrpoject, loadproject, dumpproject, renameproject.
2.9.2.1. newproject 
The command newproject is used to initiate a new project The name of the new project is entered as a value. If, however, a project with this name already exists, and the project name is alphabetic, not already ending with a number, then a 1 will be suffixed to the project name. If the project name already has a numerical suffix, then the existing numerical suffix will be increased by 1. 
So for example: HEIDEGGER > HEIDEGGER1 > HEIDEGGER2 > HEIDEGGER3
2.9.2.2. showprojects
To display all the projects that are currently attached to the notebook, type showprojects.
 
PLATE 2.83: Displaying all the projects. 
2.9.2.3. resumeproject
To resume a project that already exists, type resumeproject. If a project is already active, this will be saved before a new project is activated.
2.9.2.4. saveproject
To back up the current project, enter saveproject.
2.9.2.5. endproject, quitproject
To quit the current project, enter endproject (alternative form: quitproject).
2.9.2.6. flipproject
The command flipproject takes the indexes of the current project and sends them to the flipbook, allowing you to iterate over them.
2.9.2.7. currentproject
The command currentproject displays the indexes of the current project.
2.9.2.8. showproject
The command showproject can be used to display all the attributes of a project.
2.9.2.9. showprojectdates
The command showprojectdates, which accepts the modifiers /$ /& and /*, and two values can be used to display a chronogram of the projects. The first value can be used to restrict to a range of indexes, while the second value, or the modifiers, is used to set the determinant. The default determinant is “ymd”, whereas the first modifier selects “ym”; the second modifier ads ‘*h’, and the third modifier adds an ‘m’.
2.9.2.10. archiveproject, unarchiveproject, showarchivedprojects
The commands archiveproject and unarchiveproject can be used to move projects into and out of the archive. To see the archived projects, use showarchivedprojects.
2.9.2.11. renameproject, deletearchivedproject
Use renameproject:OLDNAME;NEWNAME to rename a project, and deletearchivedproject to delete an archived project.
2.9.2.12. dumpproject, loadproject
The command dumproject saves the projects as a textfile, named by the date of the save. The command loadproject loads a textfile and restores the projects from it. It must be used with care, since it will erase the existing projects.

 
PLATE 2.83.2 A chronogram of projects
2.10 SWITCHING 
ARCADES allows you to open several notebooks at once, switching back and forth between them.  To switch, you use the switch command. The first time that you use it, it will exit the current notebook, and allow you to enter a new one. To do so, select (N) in the input menu. Once more than one notebook is active, future uses of switch will display the active notebooks, and allow you to switch to a new one, or remain in the old one, just by typing the number corresponding to it.
When you quit a notebook, the notebook will be closed and you will be returned to the “switch”-menu. Here it is possible to quit all the active notebooks, closing ARCADES.
2.11 BUFFER
Each active notebook is a unique notebook-object. ARCADES, however, also allows you to store notes in a common register shared by all the notebooks. 

2.11.1. copyto  
Enter copyto, with a collection of indexes as a value, to copy notes into the temporary buffer.

2.11.2. copyfrom
Enter copyfrom, with a single value indicating the number of notes, or using the modifier /$ to indicate all the notes in the temporary buffer.
The temporary buffer functions stack -- first in/first out – and notes are deleted as soon as they are “copied” out of it.
 
PLATE 2.84: Switching between notebooks.
 
PLATE 2.85: Copying to the buffer.
 
PLATE 2.86: Copying from the buffer.
2.12. ADVANCED REFEEDING COMMANDS
So as to increase the usefulness of ARCADES’s ability to “refeed” the results of commands, a number of advanced commands are available. These allow one to load text files into ARCADES, save them back to the hard drive, or even upload a function written into Python  and apply it to the text. 
2.12.1 load
The command load, which accepts a filename as a value, loads a text file and feeds it into the text command. If no value is entered, then it will call up the file menu.
 
PLATE 2.87: Inserting a text file into a note by loading and refeeding.
2.12.2 save
The save command saves a text file to the disk drive. It accepts three values: the text to be saved, the filename, and the folder, which defaults to ‘/textfiles.’
The save command can be used both to save the text of a note, as well as formatted output, and hence can be combined with a variety of other commands, including show, multi, and also explode. 



2.13.4. echo
The command echo simply prints the text in the value. It can be used with loadtext, and is also a useful way of inspecting the output sent to variables. 
 
PLATE 2:88: Echoing. 
2.12.4. run
ARCADES allows you to apply user-defined Python scripts to process text. The script in question should be a function, named “generic,” that accepts a single string as its value and returns a single string, and it should be saved as a “.py’ file in the “/programs” folder. To apply the program to text, simply use the run command, which accepts two values: the name of the program, and the text itself to be processed. The text can be entered directly, but you can also use a variable or the quadruple question marks. 
 
PLATE 2.89: Example of a valid program. 
The above (PLATE  2.89) is an example of a program, used to turn a list of Korean vocabulary words, downloaded from the Web, into a flashcard script.
 
It yields text formatted like this, which can, in turn, be interpreted by ARCADES as two-sided flashcards. 
 
 
PLATE 2.90: When run is activated, the program is loaded and displayed. The result of the conversion has been sent to “echo.”
2.12.5. interpret
The command interpret can be used to interpret the text of a notescript given as the value.
2.12.6. runinterpret
The command runinterpret combines loadtext and run: it interprets a text file after having applied a Python script to it. The command runinterpret accepts two values: the name of the file, in the directory “/programs”, of the program to be run, and the name of the text file to which it is to be applied.
2.12.7. explode
The command explode yields an index, keyword list, and text from a single note, which in turn can be accessed with single, double, and quadruple question marks.
2.12.8. invert
The command invert takes a list of indexes and yields a list of all the indexes that are contained in the notebook yet not in the list.
2.12.9. keys
The command keys (alternative forms: key, k) can be used to refeed a collection of keys into another command. It accepts one value – the collection of indexes from which the keys are to be taken – and the modifiers /$, /&, /*, /?. The modifier /$ generates a histogram from the keys, whereas the modifiers /&, /*, and /?, are used, respectively, to include “all-cap,” capitalized, and lower-case keywords. If neither of these three modifiers are invoked, then it will show all keywords. 
This generates a search phrase, which can be refed into another command by using double question marks (??).
2.12.10. tags
The command tags (alternate forms: tag, t) displays the tags from a collection of indexes, given as its first value.
This generates a search phrase, which can be refed into another command by using double question marks (??).
2.12.11. text
The command text, which accepts three values and the modifiers /$, /&, and /*, is used to show the most relevant words in a text, determined according to either their frequency in the note, their scarcity in the notebook, or both.
The first value is the collection of indexes, the second value is the number of words according to frequency in text, and third value is the number of words according to their scarcity in the notebook.
The modifier /$ presents the intersection of both sets, while the modifier /& presents them by decreasing frequency in the notebook and /* by increasing frequency in the text of the selected notes.
2.13. MACROS, DEFINITIONS, AND KNOWLEDGE 
ARCADES offers various different kind of simple macros, which can be used for entering commands, keywords, and text. These include:
	(1) codes 		| used to define special codes for text entry.
	(2) macros 		| used as shorthand in entering text
	(3) keymacros 		| used in entering keywords
	(4) command macros	| used for entering commands 
In addition to these macros functions, other features in ARCADES share similar functionality.
These are:
	(5) key definitions 	| used to automatically assign keywords to text
	(6) knowledge  		| the “knowledge base” for defining metatags.
	(7) spelling 		| words added to the spelling dictionaries.
2.13.1. Basic functionality
The following is an account of the basic functionality of  codes, macros, key macros, and command marcros. The treatment of the key definitions, knowledge base, and spelling dictionary will be treated separately.
2.13.1.1. Codes
Codes are used for entering special characters, and especially those which have a reserved function in ARCADES, such as the left arrow (<) and right arrow (>).
4 codes are predefined in ARCADES:
(1) < = /060/   	(2)  > = /062/    
(3) { =/123/		(4)  } =/125/
The use of the slash is not inherent to a code. But it is recommended that you only define codes that are unlikely to appear in ordinary text.
2.13.1.2. Macros
Macros are used to facilitate entry of commonly used terms. Codes are different from macros in several respects:
	1) There are no predefined macros.
	2) To be invoked, a macro must be preceded by an underline (_) .
	3) When defining codes, the “from” and “to” seem to be reversed. 
This last point is a bit tricky and confusing. The reason has to do with the fact that, in the case of codes, the code itself is the expansion of the symbol to which it correlates. 
2.13.1.3. Key macros
Key macros are used specifically for facilitating the entry of a sequence of keywords. They offer an alternative to default keywords and projects.  If you are simultaneously working on several different notetaking projects at once, it might make sense, instead of constantly switching between projects, to define a key macro. Once a key macro has been defined, it can be invoked, when entering keywords, by preceding it with a DOLLAR ($). 
 
PLATE 2.91: Using predefined codes.
 
PLATE 2.92: With the macros ph=philosophy, Hei=Heidegger, Heg=Hegel.
.
 
PLATE 2.93: The key macro “FROG” expands to the terms: Girin/enemy, Gom/enemy, Juveee/child, Lupu/frog, Seojin/friend, green/color.
2.13.1.4. Command macros
Command macros can be used either to redefine commands, or facilitate the entry of a string of commands. 
In the following example, the rather useless macro “firstten” is defined as “show:1-10,” showing the first ten notes in the notebook.
 
PLATE 2.94: Defining and using a command macro.
It is important to use some care in defining command macros, and, above all, make sure that they don’t interact with other elements of the command phrase or overwrite existing commands.
 
PLATE 2.95: Once the command macro “firstten” has been defined, it cannot be directly entered into the text of the note through the command prompt. 
It is recommended, indeed, either only to use unusual terms for command macros or to precede them with some symbol, such as a DOLLAR.
2.13.1.5. Advanced command macro definitions.
ARCADES offers some special codes for entering more sophisticated command macros. To activate these, the entire command macro must be preceded by an AT.
These include: 
	(1)	FIRST 		|the first index
	(2)	LAST		| the last index
	(3) 	FILE		| the name of the current file
	(4) 	BACKUP	| the current filename combined the current date
	(5)	NOW		| POUND + the current date
It is also possible to include queries, simply by including the query phrase in square brackets.



2.13.2 Macro commands
ARCADES offers four classes of commands for managing macros: change, default, record, clear. Each of these combines with the four types of macros to yield sixteen distinct commands:
	(1) changecodes
	(2) changemacros
	(3) changekeymacros
	(4) changecommandmacros
	(5) defaultcodes
	(6) defaultmacros
	(7) defautkeymacros
	(8) defaultcommandmacros
	(9) recordcodes
	(10) recordmacros
	(11) recordkeymacros
	(12) recordcommandmacros
	(13) clearcodes
	(14) clearmacros
	(15) clearkeymacros
	(16) clearcommandmacros

2.13.2.1 changecodes, changemacros, changekeymacros, changecommandmacros
These commands all call up the “console,” which allows for the entry and deletion of the four different kinds of macros.
 
PLATE 2.96: The macro-console

2.13.2.2 defaultcodes, defaultmacros, defaultkeymacros, defaultcommandmacros
In addition to entering macros through the console, it is also possible to load macros from notes contained within a notebook.  These notes can, likewise, be easily transferred between notebooks (using formout and loadtext). 
The “default” commands all work in the same way. They search for all the notes in the notebook with a certain identifying keyword, and then interpret the text contained in these notes.
2.13.2.2.1. The identifying keyword
The identifying keyword consists in two parts: an identifying key, and an optional suffix.

2.13.2.2.1.1. The identifying key
The identifying key is simply the type of macro written out in all-caps.
	(1) codes 			| CODES
	(2) macros			| MACROS
	(3) keymacros			| KEYMACROS
	(4) commandmacros 		| COMMANDMACROS
2.13.2.2.1.2. The suffix
The suffix is Unicode-8 string that can be entered through the terminal, excluding special characters that would interfere with keyword entry such as SLASH (/), PERIOD (/), COMMA (,), or AT (@).
Valid suffixes include:
	(1) 	| 1
	(2)	| frog
	(3) 	| $
	(4) 	| This is a suffix
2.13.2.2.2. The text of the default note
The text of the default note consists simply in a list of “equations.”
It is important to avoid spaces within the equation, since these will be interpreted as demarcating separate codes.
2.12.2.2.2.1. Some examples
The following are some further examples of how codes, macros, command macros, and key macros can be used. 




 
PLATE 2.97: EXAMPLE #1: German special character codes

 
PLATE 2.98: EXAMPLE #2: Macros for the names of philosophers
Notice that the tilde (~) is converted into a space when the macro is loaded; this prevents the title from being cut off after the first word.
. 
 
 
PLATE 2.99: EXAMPLE #3: Command macros
 
PLATE 2.100: EXAMPLE #4: Key macros. 
Notice the KEYMACROS use a COLON (:) instead of EQUAL (=).
2.13.2.3 recordcodes, recordmacros, recordkeymacros, recordcommandmacros
The “record”-commands can be used to record macro definitions to a note. 
 
PLATE 2.101: Recording macro definitions to a note.
*2.13.2.4. clearcodes, clearmacros, clearkeymacros, clearcommandmacros
While it is possible to clear all entries in a macro through the console, this does not actually destroy and reconstitute an object, as may be necessary if you make changes to the Python modules defining the objects (“abbreviations.py”, “keydefinitions.py”, “keymacrodefinitions.py”). To do this, you must use the “clear”-commands.

2.14. KNOWLEDGEBASE
ARCADES includes a simple “knowledge base,” which can be used to define ontological facts and apply these in executing searches. An ontological fact consists in the knowledge that one kind of thing can be subsumed under another kind of thing. For example:
	(1)  a “ontologist” is a “philosopher”
	(2) a “philosopher” is a “theorist”
	(3) a “theorist” is a “scientist”
	(4) a “scientist” is a “thinker”
	(5) a “thinker” is a “human being”
	(6) a “human being” is an “animal”
	(7) an “animal” is a “living being”
	(8) a “living being” is a “being”
Given these definitions, it would then be possible to search for all “ontologists” by searching for “scientist” or “human being” or even “being.” And we might add these two further definitions:
	(9) an “oncologist” is a “medical doctor”
	(10) a “medical doctor” is a “scientist”
Then “scientist” would search for both “ontologist” and “oncologist.”
The lowest level classification (“ontologist”) is a “tag,” where the higher classifications are “meta-tags.” The reason for this distinction, which might seem arbitrary, is because the knowledge base and the tags are stored separately. The metatags can be thought of as a classificatory schemes supervening on the keys and tags, and is, indeed, much easier to change and manipulate. Knowledge can be easily forgotten without changing the notebook itself!
2.14.1. Defining knowledge when entering keys
It is possible to “teach” ARCADES an ontological fact when entering keywords with tags. Simply use EQUAL (=) after the tag, followed by the metatag.
For example:
	(1) Heidegger/philosopher=thinker
	(2) Rilke/poet=author
2.14.2. Knowledge commands: learn, forget, allknowledge
Ontologically facts can be defined directly through the commands learn and forget. Both take two values: the lower-level classification and the higher-level classification.
The command allknowledge presents all the ontological facts that ARCADES has been taught.
 
PLATE 2.102. The knowledge base (example 1).

 
PLATE 2.103: The knowledge base (Example 2) 
2.14.3. The “knowledge” console
The “knowledge base” also has the following console commands, whose operation is completely analogous to the four macros: changeknowledge, defaultknowledge, recordknowledge, clearknowledge. 
Knowledge is recorded using EQUAL  (=).
 
PLATE 2.104: Loading knowledge from a note. 
 
PLATE 2.105: Saving knowledge to a note.
2.15. KEY DEFINITIONS
ARCADES allows you to load text by paragraph, converting each paragraph into a note, while automatically assigning keywords to each note based on the words that appear in the text. 
2.15.1 Loading by paragraph
Loading raw text into ARCADES can be initiated through two different commands: loadbyparagraph and splitload. They differ in only one respect: loadbyparagraph splits up the text using the paragraph mark (“/n”), whereas splitload splits on a user-defined string.
The command splitbyparagraph accepts one value – the name of the file to be loaded – and the modifiers /$, /&, /*.  The first modifier is used to suppress the “key” function, which calls up existing keys. The “key” function is automatically suppressed if there are more than 50 keys in the notebook. The second modifier is used to invoke automatic key definitions. The third modifier is used to repress querying the user to add notes and continue. 
The command splitload is similar, except that it accepts, as a second value, the character string used to split the text into paragraphs.
2.15.2. The console-commands
The commands changekeydefinitions, defaultkeydefinitions, recordkeydefinitions, and clearkeydefinitions can be used to define and change key definitions. 
The formatting of default key definitions is as follows:
	KEY:DEFINITION1,DEFINITION2,DEFINITION3…
The “definitions” are the words in the text corresponding to a given key.
 
PLATE 2.105: A simple example of automatic key definitions.

 
PLATE 2. 106: (1/3) The key definitions and the text to which they are applied. 
 
PLATE 2.107: (2/3) The application of the key definitions. (II)
The text has been divided into paragraphs.

 
PLATE 2.108: (3/3). The final result of the application.
2.16. SPELLING
ARCADES includes a basic spellchecker, with support for English, French, Spanish, and German. The spellingchecker includes the capacity to learn new words, and keeps separate dictionaries for all dictionaries. New words can be added during text entry, through a “Console”, or by loading in new words from notes.
2.16.1. Activating and deactivating the spellchecker
Use the spelling command to toggle the spellchecker on or off.
2.16.2. Selecting a language
The spellchecker allows you to choose between English, French, Spanish, and German. To do so, use the language command with “en”, “es”, “fr”, “de” as a value.
2.16.2 Using the spellchecker during text entry
If the spellchecker is activated, then ARCADES, following text entry, ultimately checks for misspelled words. It checks using the dictionary of the language that has been selected, although it automatically switches to German if an excessive number of errors in the other language are present.
2.16.3. Using the console
To call up the console, use the command spelldictionary. The console allows you to add new words, delete words, change the language, and display the words that have been added.


 
PLATE 2. 109 Adding new words during spell check (before).
 
PLATE 2. 110: Adding new words during spell check. (after)


 
PLATE 2.111: The spelling console.
2.16.4 Loading from notes
The defaultspelling command operates analogously to the “default”-commands for macros, key definitions, and the knowledge base. There are only two differences.
(1) The suffix must contain the language-abbreviation (“en”, “es”, “de”, “fr”) in addition to the optional specifier.
(2) The text consists simply in a list of words to be added to the spelling dictionary for the language indicated.

 
PLATE 2.112: Loading new words into the spelling dictionary from a note.

2.17. SETTINGS, CONFIGURATIONS, MENUS, AND HELP
2.17.1. Settings
The command showsettings can be used to show all the string, integer, and Boolean values stored as persistent properties. Most, but not all, of these properties can be manually adjusted.
2.17.1.1. Miscellaneous binary commands
	(1) 	usesequence	| disables use of sequences
	(2)	boxconfigs	| displays configuration in a “boxy” way.
	(3)	autobackup	| disables automatic backup 
	(4) 	curtail		| eliminates lines at beginning of note
	(5) 	showdate 	| shows dates when displaying note
	(6) 	showshow	| displays all notes in short form
	(7) 	carryoverkeys	| carries over keys from parents to children
	(8)	carryall 	| carries over keys from all parents, or first two parents
	(9)	negresults	| includes negative indexes in search results
2.17.1.2. Miscellaneous integer settings
	(10) 	trim 		| sets the length of all keywords when displaying notes as list
	(11) 	setlongmax 	| sets the maximum number of notes shown in “long” mode
	(12) 	smallsize 	| sets the small size of notes for multidisplay
2.17.2. Configurations
The commands showconfigurations can be used to show the non-persistent attributes of the notebook.
2.17.2.1 The command saveconfigurations and loadconfigurations
The commands saveconfigurations and loadconfigurations can be used to save and load configurations. Both accept a single value: the identifier of the configurations. The configurations are save as a .pkl file, with “_config.pkl” automatically added to the identifier to yield the filename.
2.17.3. Help and menus
2.17.3.1. Menus 
The command bigmenu displays a large menu showing all the commands, while menu calls up a top-level menu from which the lower-level menus can be selected.  Both menus can be used to enter commands.  The bigmenu is so large that it is nearly impossible to get it to display properly without a special monitor
 
PLATE 2.113: Settings
 
PLATE 2.114: Configurations 

 
PLATE 2.115: The small help menu.

 
PLATE 2.116: The help screen.
The command help shows the commands, together with information about them, as one of a series of tables, allow the user to move back and forth between them.
 
PLATE 2.117: The command help may also accept as a value the name of a command.




2.18. HOUSEKEEPING
2.18.1 Houskeeping commands
ARCADES offers a few commands that can be used for “housekeeping.” These include:
	(1)	refresh		| Reconstitutes the word dictionary
	(2) 	updatetags	| Goes through all the keys in the notebook and updates tags
2.18.2  Diagnostics 
In order to faciliate the diagnostics of problems with the consistency of notebook (the correspondence of the notebook keys with the dictionaries kept in the pickle file), ARCADES automatically records all actions taken in the notebook, as well as the result of the inconsistency test, to a textfile, identified by the name of the notebook  + DIAG. 

 
PLATE 2.118 An example of a diagnostic text file.

2.18.4 The register.
ARCADES automatically keeps track which notebooks have been opened and closed, as well as the projects that were activated while they were open, and the index position at the time of closing.
Upon starting up, ARCADES gives you the option of viewing the register. It is possible either to see the entire registry, or to search for a notebook, a projectname, a status, or even for notebooks that were accessed within a certain time period.
 
PLATE 2.119 The registry menu
 
PLATE 2.120 The registry
2.18.4.1 Protection again file corruption
Because shelves are not designed to handle simultaneous access, and because, moreover, the metadata for each notebook is kept in a separate file, ARCADES uses the registry to prevent you from opening a notebook  that has not been properly closed.
If you attempt to open a file that has not been closed, ARCADES will display an alert, and the give you several options. You can either open it as a read only notebook, with all notebook modifying functions suspending, or go back to the main notebook selection menu, or – if you have ascertained that the file is not presently open but was simply not closed properly – you can correct the registry and continue. 

 
